   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"PollQ.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.vPolledQueueProducer,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	vPolledQueueProducer:
  24              	.LFB1:
  25              		.file 1 "../FreeRTOS/Demo/Common/Minimal/PollQ.c"
   1:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /*
   2:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	
   4:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
   5:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     ***************************************************************************
   6:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *                                                                       *
   7:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    available.                                                         *
  10:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *                                                                       *
  11:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *                                                                       *
  18:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *                                                                       *
  20:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****      *                                                                       *
  22:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     ***************************************************************************
  23:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  24:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  25:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  27:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  42:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  44:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     contact details.
  46:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  47:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     critical systems.
  49:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  50:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****     licensing and training services.
  52:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** */
  53:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  54:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /*
  55:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * This version of PollQ. c is for use on systems that have limited stack
  56:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * space and no display facilities.  The complete version can be found in
  57:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * the Demo/Common/Full directory.
  58:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  *
  59:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * Creates two tasks that communicate over a single queue.  One task acts as a
  60:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * producer, the other a consumer.
  61:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  *
  62:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * The producer loops for three iteration, posting an incrementing number onto the
  63:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * queue each cycle.  It then delays for a fixed period before doing exactly the
  64:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * same again.
  65:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  *
  66:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * The consumer loops emptying the queue.  Each item removed from the queue is
  67:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * checked to ensure it contains the expected value.  When the queue is empty it
  68:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * blocks for a fixed period, then does the same again.
  69:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  *
  70:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * All queue access is performed without blocking.  The consumer completely empties
  71:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * the queue each time it runs so the producer should never find the queue full.
  72:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  *
  73:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * An error is flagged if the consumer obtains an unexpected value or the producer
  74:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  * find the queue is full.
  75:../FreeRTOS/Demo/Common/Minimal/PollQ.c ****  */
  76:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  77:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /*
  78:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** Changes from V2.0.0
  79:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  80:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	+ Delay periods are now specified using variables and constants of
  81:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	  portTickType rather than unsigned long.
  82:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** */
  83:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  84:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #include <stdlib.h>
  85:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  86:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /* Scheduler include files. */
  87:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #include "FreeRTOS.h"
  88:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #include "task.h"
  89:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #include "queue.h"
  90:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  91:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /* Demo program include files. */
  92:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #include "PollQ.h"
  93:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
  94:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #define pollqSTACK_SIZE			configMINIMAL_STACK_SIZE
  95:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #define pollqQUEUE_SIZE			( 10 )
  96:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #define pollqPRODUCER_DELAY		( ( portTickType ) 200 / portTICK_RATE_MS )
  97:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #define pollqCONSUMER_DELAY		( pollqPRODUCER_DELAY - ( portTickType ) ( 20 / portTICK_RATE_MS ) )
  98:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #define pollqNO_DELAY			( ( portTickType ) 0 )
  99:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #define pollqVALUES_TO_PRODUCE	( ( signed portBASE_TYPE ) 3 )
 100:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** #define pollqINITIAL_VALUE		( ( signed portBASE_TYPE ) 0 )
 101:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 102:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /* The task that posts the incrementing number onto the queue. */
 103:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** static portTASK_FUNCTION_PROTO( vPolledQueueProducer, pvParameters );
 104:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 105:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /* The task that empties the queue. */
 106:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** static portTASK_FUNCTION_PROTO( vPolledQueueConsumer, pvParameters );
 107:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 108:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /* Variables that are used to check that the tasks are still running with no
 109:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** errors. */
 110:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCo
 111:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 112:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 113:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 114:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
 115:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 116:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** static xQueueHandle xPolledQueue;
 117:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 118:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	/* Create the queue used by the producer and consumer. */
 119:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) 
 120:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 121:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 122:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	in use.  The queue registry is provided as a means for kernel aware 
 123:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 124:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 125:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
 126:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	defined to be less than 1. */
 127:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );
 128:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 129:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	/* Spawn the producer and consumer. */
 130:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPoll
 131:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPoll
 132:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** }
 133:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 134:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 135:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
 136:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
  26              		.loc 1 136 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 24
  34              		.cfi_offset 14, -4
  35              		.cfi_offset 8, -8
  36              		.cfi_offset 7, -12
  37              		.cfi_offset 6, -16
  38              		.cfi_offset 5, -20
  39              		.cfi_offset 4, -24
  40 0004 82B0     		sub	sp, sp, #8
  41              	.LCFI1:
  42              		.cfi_def_cfa_offset 32
 137:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** unsigned short usValue = ( unsigned short ) 0;
  43              		.loc 1 137 0
  44 0006 02AD     		add	r5, sp, #8
 138:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE, xLoop;
 139:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 140:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	for( ;; )
 141:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	{		
 142:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
  45              		.loc 1 142 0
  46 0008 0024     		movs	r4, #0
  47 000a 40F20008 		movw	r8, #:lower16:.LANCHOR0
 137:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** unsigned short usValue = ( unsigned short ) 0;
  48              		.loc 1 137 0
  49 000e 0023     		movs	r3, #0
 136:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
  50              		.loc 1 136 0
  51 0010 0646     		mov	r6, r0
 137:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** unsigned short usValue = ( unsigned short ) 0;
  52              		.loc 1 137 0
  53 0012 25F8023D 		strh	r3, [r5, #-2]!	@ movhi
  54              	.LVL1:
 138:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE, xLoop;
  55              		.loc 1 138 0
  56 0016 2746     		mov	r7, r4
  57 0018 C0F20008 		movt	r8, #:upper16:.LANCHOR0
  58              	.LVL2:
  59              	.L8:
  60              		.loc 1 142 0 discriminator 1
  61 001c 022C     		cmp	r4, #2
  62 001e 03DD     		ble	.L5
 143:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		{
 144:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			/* Send an incrementing number on the queue without blocking. */
 145:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pd
 146:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			{
 147:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				/* We should never find the queue full so if we get here there
 148:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				has been an error. */
 149:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				xError = pdTRUE;
 150:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			}
 151:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			else
 152:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			{
 153:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				if( xError == pdFALSE )
 154:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				{
 155:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					/* If an error has ever been recorded we stop incrementing the
 156:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					check variable. */
 157:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					portENTER_CRITICAL();
 158:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						xPollingProducerCount++;
 159:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					portEXIT_CRITICAL();
 160:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				}
 161:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 162:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				/* Update the value we are going to post next time around. */
 163:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				usValue++;
 164:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			}
 165:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		}
 166:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 167:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		/* Wait before we start posting again to ensure the consumer runs and
 168:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		empties the queue. */
 169:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		vTaskDelay( pollqPRODUCER_DELAY );
  63              		.loc 1 169 0
  64 0020 C820     		movs	r0, #200
  65 0022 FFF7FEFF 		bl	vTaskDelay
 142:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
  66              		.loc 1 142 0
  67 0026 0024     		movs	r4, #0
  68              	.LVL3:
  69              	.L5:
 145:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pd
  70              		.loc 1 145 0
  71 0028 0022     		movs	r2, #0
  72 002a 2946     		mov	r1, r5
  73 002c 1346     		mov	r3, r2
  74 002e 3068     		ldr	r0, [r6, #0]
  75 0030 FFF7FEFF 		bl	xQueueGenericSend
  76 0034 0128     		cmp	r0, #1
  77 0036 02D0     		beq	.L10
 149:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				xError = pdTRUE;
  78              		.loc 1 149 0
  79 0038 0127     		movs	r7, #1
  80              	.LVL4:
 142:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
  81              		.loc 1 142 0
  82 003a 0134     		adds	r4, r4, #1
  83 003c EEE7     		b	.L8
  84              	.L10:
 153:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				if( xError == pdFALSE )
  85              		.loc 1 153 0
  86 003e 37B1     		cbz	r7, .L11
  87              	.L4:
 163:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				usValue++;
  88              		.loc 1 163 0
  89 0040 BDF80630 		ldrh	r3, [sp, #6]
 142:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
  90              		.loc 1 142 0
  91 0044 0134     		adds	r4, r4, #1
 163:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				usValue++;
  92              		.loc 1 163 0
  93 0046 5A1C     		adds	r2, r3, #1
  94 0048 ADF80620 		strh	r2, [sp, #6]	@ movhi
  95              	.LVL5:
  96 004c E6E7     		b	.L8
  97              	.L11:
 157:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					portENTER_CRITICAL();
  98              		.loc 1 157 0
  99 004e FFF7FEFF 		bl	vPortEnterCritical
 158:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						xPollingProducerCount++;
 100              		.loc 1 158 0
 101 0052 D8F80010 		ldr	r1, [r8, #0]
 102 0056 481C     		adds	r0, r1, #1
 103 0058 C8F80000 		str	r0, [r8, #0]
 159:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					portEXIT_CRITICAL();
 104              		.loc 1 159 0
 105 005c FFF7FEFF 		bl	vPortExitCritical
 106 0060 EEE7     		b	.L4
 107              		.cfi_endproc
 108              	.LFE1:
 110 0062 00BF     		.section	.text.vPolledQueueConsumer,"ax",%progbits
 111              		.align	2
 112              		.thumb
 113              		.thumb_func
 115              	vPolledQueueConsumer:
 116              	.LFB2:
 170:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	}
 171:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** }  /*lint !e818 Function prototype must conform to API. */
 172:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 173:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 174:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
 175:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 117              		.loc 1 175 0
 118              		.cfi_startproc
 119              		@ args = 0, pretend = 0, frame = 8
 120              		@ frame_needed = 0, uses_anonymous_args = 0
 121              	.LVL6:
 122 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 123              	.LCFI2:
 124              		.cfi_def_cfa_offset 24
 125              		.cfi_offset 14, -4
 126              		.cfi_offset 8, -8
 127              		.cfi_offset 7, -12
 128              		.cfi_offset 6, -16
 129              		.cfi_offset 5, -20
 130              		.cfi_offset 4, -24
 176:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** unsigned short usData, usExpectedValue = ( unsigned short ) 0;
 177:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE;
 131              		.loc 1 177 0
 132 0004 0026     		movs	r6, #0
 133 0006 40F20007 		movw	r7, #:lower16:.LANCHOR1
 175:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 134              		.loc 1 175 0
 135 000a 82B0     		sub	sp, sp, #8
 136              	.LCFI3:
 137              		.cfi_def_cfa_offset 32
 175:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 138              		.loc 1 175 0
 139 000c 0446     		mov	r4, r0
 176:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** unsigned short usData, usExpectedValue = ( unsigned short ) 0;
 140              		.loc 1 176 0
 141 000e 3546     		mov	r5, r6
 142 0010 C0F20007 		movt	r7, #:upper16:.LANCHOR1
 143              	.LVL7:
 144              	.L20:
 178:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 179:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	for( ;; )
 180:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	{		
 181:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		/* Loop until the queue is empty. */
 182:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
 145              		.loc 1 182 0 discriminator 1
 146 0014 2068     		ldr	r0, [r4, #0]
 147 0016 FFF7FEFF 		bl	uxQueueMessagesWaiting
 148 001a 38B9     		cbnz	r0, .L16
 149              	.LVL8:
 150              	.L21:
 183:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		{
 184:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
 185:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			{
 186:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				if( usData != usExpectedValue )
 187:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				{
 188:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					/* This is not what we expected to receive so an error has
 189:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					occurred. */
 190:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					xError = pdTRUE;
 191:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 192:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					/* Catch-up to the value we received so our next expected
 193:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					value should again be correct. */
 194:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					usExpectedValue = usData;
 195:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				}
 196:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				else
 197:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				{
 198:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					if( xError == pdFALSE )
 199:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					{
 200:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						/* Only increment the check variable if no errors have
 201:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						occurred. */
 202:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						portENTER_CRITICAL();
 203:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 							xPollingConsumerCount++;
 204:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						portEXIT_CRITICAL();
 205:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					}
 206:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				}
 207:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 208:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				/* Next time round we would expect the number to be one higher. */
 209:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				usExpectedValue++;
 210:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			}
 211:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		}
 212:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 213:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		/* Now the queue is empty we block, allowing the producer to place more
 214:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		items in the queue. */
 215:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		vTaskDelay( pollqCONSUMER_DELAY );
 151              		.loc 1 215 0
 152 001c B420     		movs	r0, #180
 153 001e FFF7FEFF 		bl	vTaskDelay
 154              	.LVL9:
 182:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
 155              		.loc 1 182 0
 156 0022 2068     		ldr	r0, [r4, #0]
 157 0024 FFF7FEFF 		bl	uxQueueMessagesWaiting
 158 0028 0028     		cmp	r0, #0
 159 002a F7D0     		beq	.L21
 160              	.LVL10:
 161              	.L16:
 184:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
 162              		.loc 1 184 0
 163 002c 0022     		movs	r2, #0
 164 002e 0DF10601 		add	r1, sp, #6
 165 0032 1346     		mov	r3, r2
 166 0034 2068     		ldr	r0, [r4, #0]
 167 0036 FFF7FEFF 		bl	xQueueGenericReceive
 168 003a 0128     		cmp	r0, #1
 169 003c EAD1     		bne	.L20
 186:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				if( usData != usExpectedValue )
 170              		.loc 1 186 0
 171 003e BDF80680 		ldrh	r8, [sp, #6]
 172 0042 A845     		cmp	r8, r5
 190:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					xError = pdTRUE;
 173              		.loc 1 190 0
 174 0044 18BF     		it	ne
 175 0046 0646     		movne	r6, r0
 176              	.LVL11:
 186:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				if( usData != usExpectedValue )
 177              		.loc 1 186 0
 178 0048 03D0     		beq	.L22
 179              	.L15:
 180              	.LVL12:
 209:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 				usExpectedValue++;
 181              		.loc 1 209 0
 182 004a 08F10105 		add	r5, r8, #1
 183 004e ADB2     		uxth	r5, r5
 184              	.LVL13:
 185 0050 E0E7     		b	.L20
 186              	.LVL14:
 187              	.L22:
 198:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 					if( xError == pdFALSE )
 188              		.loc 1 198 0
 189 0052 002E     		cmp	r6, #0
 190 0054 F9D1     		bne	.L15
 202:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						portENTER_CRITICAL();
 191              		.loc 1 202 0
 192 0056 FFF7FEFF 		bl	vPortEnterCritical
 203:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 							xPollingConsumerCount++;
 193              		.loc 1 203 0
 194 005a 3868     		ldr	r0, [r7, #0]
 195 005c 431C     		adds	r3, r0, #1
 196 005e 3B60     		str	r3, [r7, #0]
 204:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 						portEXIT_CRITICAL();
 197              		.loc 1 204 0
 198 0060 FFF7FEFF 		bl	vPortExitCritical
 199 0064 F1E7     		b	.L15
 200              		.cfi_endproc
 201              	.LFE2:
 203 0066 00BF     		.section	.text.vStartPolledQueueTasks,"ax",%progbits
 204              		.align	2
 205              		.global	vStartPolledQueueTasks
 206              		.thumb
 207              		.thumb_func
 209              	vStartPolledQueueTasks:
 210              	.LFB0:
 115:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 211              		.loc 1 115 0
 212              		.cfi_startproc
 213              		@ args = 0, pretend = 0, frame = 0
 214              		@ frame_needed = 0, uses_anonymous_args = 0
 215              	.LVL15:
 216 0000 70B5     		push	{r4, r5, r6, lr}
 217              	.LCFI4:
 218              		.cfi_def_cfa_offset 16
 219              		.cfi_offset 14, -4
 220              		.cfi_offset 6, -8
 221              		.cfi_offset 5, -12
 222              		.cfi_offset 4, -16
 119:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) 
 223              		.loc 1 119 0
 224 0002 0221     		movs	r1, #2
 115:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 225              		.loc 1 115 0
 226 0004 84B0     		sub	sp, sp, #16
 227              	.LCFI5:
 228              		.cfi_def_cfa_offset 32
 115:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 229              		.loc 1 115 0
 230 0006 0646     		mov	r6, r0
 119:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) 
 231              		.loc 1 119 0
 232 0008 0022     		movs	r2, #0
 233 000a 0A20     		movs	r0, #10
 234              	.LVL16:
 235 000c FFF7FEFF 		bl	xQueueGenericCreate
 236 0010 40F20005 		movw	r5, #:lower16:.LANCHOR2
 237 0014 C0F20005 		movt	r5, #:upper16:.LANCHOR2
 238 0018 2860     		str	r0, [r5, #0]
 130:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPoll
 239              		.loc 1 130 0
 240 001a 40F20001 		movw	r1, #:lower16:.LC0
 241 001e 40F20000 		movw	r0, #:lower16:vPolledQueueConsumer
 242 0022 0024     		movs	r4, #0
 243 0024 7822     		movs	r2, #120
 244 0026 2B46     		mov	r3, r5
 245 0028 C0F20001 		movt	r1, #:upper16:.LC0
 246 002c C0F20000 		movt	r0, #:upper16:vPolledQueueConsumer
 247 0030 0096     		str	r6, [sp, #0]
 248 0032 0194     		str	r4, [sp, #4]
 249 0034 0294     		str	r4, [sp, #8]
 250 0036 0394     		str	r4, [sp, #12]
 251 0038 FFF7FEFF 		bl	xTaskGenericCreate
 131:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPoll
 252              		.loc 1 131 0
 253 003c 40F20000 		movw	r0, #:lower16:vPolledQueueProducer
 254 0040 40F20001 		movw	r1, #:lower16:.LC1
 255 0044 C0F20001 		movt	r1, #:upper16:.LC1
 256 0048 7822     		movs	r2, #120
 257 004a 2B46     		mov	r3, r5
 258 004c C0F20000 		movt	r0, #:upper16:vPolledQueueProducer
 259 0050 0096     		str	r6, [sp, #0]
 260 0052 0194     		str	r4, [sp, #4]
 261 0054 0294     		str	r4, [sp, #8]
 262 0056 0394     		str	r4, [sp, #12]
 263 0058 FFF7FEFF 		bl	xTaskGenericCreate
 132:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** }
 264              		.loc 1 132 0
 265 005c 04B0     		add	sp, sp, #16
 266 005e 70BD     		pop	{r4, r5, r6, pc}
 267              		.cfi_endproc
 268              	.LFE0:
 270              		.section	.text.xArePollingQueuesStillRunning,"ax",%progbits
 271              		.align	2
 272              		.global	xArePollingQueuesStillRunning
 273              		.thumb
 274              		.thumb_func
 276              	xArePollingQueuesStillRunning:
 277              	.LFB3:
 216:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	}
 217:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** } /*lint !e818 Function prototype must conform to API. */
 218:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 219:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 220:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** /* This is called to check that all the created tasks are still running with no errors. */
 221:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** portBASE_TYPE xArePollingQueuesStillRunning( void )
 222:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** {
 278              		.loc 1 222 0
 279              		.cfi_startproc
 280              		@ args = 0, pretend = 0, frame = 0
 281              		@ frame_needed = 0, uses_anonymous_args = 0
 282              		@ link register save eliminated.
 223:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** portBASE_TYPE xReturn;
 224:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 225:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	/* Check both the consumer and producer poll count to check they have both
 226:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	been changed since out last trip round.  We do not need a critical section
 227:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	around the check variables as this is called from a higher priority than
 228:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	the other tasks that access the same variables. */
 229:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 283              		.loc 1 229 0
 284 0000 40F20001 		movw	r1, #:lower16:.LANCHOR1
 285 0004 C0F20001 		movt	r1, #:upper16:.LANCHOR1
 286 0008 0868     		ldr	r0, [r1, #0]
 287 000a 40F20003 		movw	r3, #:lower16:.LANCHOR0
 288 000e C0F20003 		movt	r3, #:upper16:.LANCHOR0
 289 0012 18B1     		cbz	r0, .L25
 230:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		( xPollingProducerCount == pollqINITIAL_VALUE )
 290              		.loc 1 230 0 discriminator 1
 291 0014 1868     		ldr	r0, [r3, #0]
 231:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	  )
 232:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	{
 233:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		xReturn = pdFALSE;
 292              		.loc 1 233 0 discriminator 1
 293 0016 0030     		adds	r0, r0, #0
 294 0018 18BF     		it	ne
 295 001a 0120     		movne	r0, #1
 296              	.L25:
 297              	.LVL17:
 234:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	}
 235:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	else
 236:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	{
 237:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 		xReturn = pdTRUE;
 238:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	}
 239:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 240:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	/* Set the check variables back down so we know if they have been
 241:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	incremented the next time around. */
 242:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xPollingConsumerCount = pollqINITIAL_VALUE;
 298              		.loc 1 242 0
 299 001c 0022     		movs	r2, #0
 300 001e 0A60     		str	r2, [r1, #0]
 243:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	xPollingProducerCount = pollqINITIAL_VALUE;
 301              		.loc 1 243 0
 302 0020 1A60     		str	r2, [r3, #0]
 244:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 
 245:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** 	return xReturn;
 246:../FreeRTOS/Demo/Common/Minimal/PollQ.c **** }
 303              		.loc 1 246 0
 304 0022 7047     		bx	lr
 305              		.cfi_endproc
 306              	.LFE3:
 308              		.section	.bss.xPolledQueue.4770,"aw",%nobits
 309              		.align	2
 310              		.set	.LANCHOR2,. + 0
 313              	xPolledQueue.4770:
 314 0000 00000000 		.space	4
 315              		.section	.bss.xPollingProducerCount,"aw",%nobits
 316              		.align	2
 317              		.set	.LANCHOR0,. + 0
 320              	xPollingProducerCount:
 321 0000 00000000 		.space	4
 322              		.section	.rodata.str1.4,"aMS",%progbits,1
 323              		.align	2
 324              	.LC0:
 325 0000 51436F6E 		.ascii	"QConsNB\000"
 325      734E4200 
 326              	.LC1:
 327 0008 5150726F 		.ascii	"QProdNB\000"
 327      644E4200 
 328              		.section	.bss.xPollingConsumerCount,"aw",%nobits
 329              		.align	2
 330              		.set	.LANCHOR1,. + 0
 333              	xPollingConsumerCount:
 334 0000 00000000 		.space	4
 335              		.text
 336              	.Letext0:
 337              		.file 2 "../FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM3/portmacro.h"
 338              		.file 3 "../FreeRTOS/Source/include/task.h"
 339              		.file 4 "../FreeRTOS/Source/include/queue.h"
DEFINED SYMBOLS
                            *ABS*:00000000 PollQ.c
     /tmp/ccSs4sKi.s:19     .text.vPolledQueueProducer:00000000 $t
     /tmp/ccSs4sKi.s:23     .text.vPolledQueueProducer:00000000 vPolledQueueProducer
     /tmp/ccSs4sKi.s:317    .bss.xPollingProducerCount:00000000 .LANCHOR0
     /tmp/ccSs4sKi.s:111    .text.vPolledQueueConsumer:00000000 $t
     /tmp/ccSs4sKi.s:115    .text.vPolledQueueConsumer:00000000 vPolledQueueConsumer
     /tmp/ccSs4sKi.s:330    .bss.xPollingConsumerCount:00000000 .LANCHOR1
     /tmp/ccSs4sKi.s:204    .text.vStartPolledQueueTasks:00000000 $t
     /tmp/ccSs4sKi.s:209    .text.vStartPolledQueueTasks:00000000 vStartPolledQueueTasks
     /tmp/ccSs4sKi.s:310    .bss.xPolledQueue.4770:00000000 .LANCHOR2
     /tmp/ccSs4sKi.s:324    .rodata.str1.4:00000000 .LC0
     /tmp/ccSs4sKi.s:326    .rodata.str1.4:00000008 .LC1
     /tmp/ccSs4sKi.s:271    .text.xArePollingQueuesStillRunning:00000000 $t
     /tmp/ccSs4sKi.s:276    .text.xArePollingQueuesStillRunning:00000000 xArePollingQueuesStillRunning
     /tmp/ccSs4sKi.s:309    .bss.xPolledQueue.4770:00000000 $d
     /tmp/ccSs4sKi.s:313    .bss.xPolledQueue.4770:00000000 xPolledQueue.4770
     /tmp/ccSs4sKi.s:316    .bss.xPollingProducerCount:00000000 $d
     /tmp/ccSs4sKi.s:320    .bss.xPollingProducerCount:00000000 xPollingProducerCount
     /tmp/ccSs4sKi.s:323    .rodata.str1.4:00000000 $d
     /tmp/ccSs4sKi.s:329    .bss.xPollingConsumerCount:00000000 $d
     /tmp/ccSs4sKi.s:333    .bss.xPollingConsumerCount:00000000 xPollingConsumerCount
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vTaskDelay
xQueueGenericSend
vPortEnterCritical
vPortExitCritical
uxQueueMessagesWaiting
xQueueGenericReceive
xQueueGenericCreate
xTaskGenericCreate
