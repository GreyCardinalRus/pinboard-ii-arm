   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"countsem.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.prvDecrementSemaphoreCount,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	prvDecrementSemaphoreCount:
  24              	.LFB1:
  25              		.file 1 "../FreeRTOS/Demo/Common/Minimal/countsem.c"
   1:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*
   2:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	
   4:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
   5:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     ***************************************************************************
   6:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *                                                                       *
   7:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    available.                                                         *
  10:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *                                                                       *
  11:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *                                                                       *
  18:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *                                                                       *
  20:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Demo/Common/Minimal/countsem.c ****      *                                                                       *
  22:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     ***************************************************************************
  23:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  24:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  25:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  27:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  42:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  44:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     contact details.
  46:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  47:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     critical systems.
  49:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  50:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Demo/Common/Minimal/countsem.c ****     licensing and training services.
  52:../FreeRTOS/Demo/Common/Minimal/countsem.c **** */
  53:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  54:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  55:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* 
  56:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * Simple demonstration of the usage of counting semaphore.
  57:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  */
  58:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  59:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* Scheduler include files. */
  60:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #include "FreeRTOS.h"
  61:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #include "task.h"
  62:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #include "semphr.h"
  63:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  64:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* Demo program include files. */
  65:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #include "countsem.h"
  66:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  67:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* The maximum count value that the semaphore used for the demo can hold. */
  68:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #define countMAX_COUNT_VALUE	( 200 )
  69:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  70:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* Constants used to indicate whether or not the semaphore should have been
  71:../FreeRTOS/Demo/Common/Minimal/countsem.c **** created with its maximum count value, or its minimum count value.  These 
  72:../FreeRTOS/Demo/Common/Minimal/countsem.c **** numbers are used to ensure that the pointers passed in as the task parameters
  73:../FreeRTOS/Demo/Common/Minimal/countsem.c **** are valid. */
  74:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #define countSTART_AT_MAX_COUNT	( 0xaa )
  75:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #define countSTART_AT_ZERO		( 0x55 )
  76:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  77:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* Two tasks are created for the test.  One uses a semaphore created with its
  78:../FreeRTOS/Demo/Common/Minimal/countsem.c **** count value set to the maximum, and one with the count value set to zero. */
  79:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #define countNUM_TEST_TASKS		( 2 )
  80:../FreeRTOS/Demo/Common/Minimal/countsem.c **** #define countDONT_BLOCK			( 0 )
  81:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  82:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
  83:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  84:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* Flag that will be latched to pdTRUE should any unexpected behaviour be
  85:../FreeRTOS/Demo/Common/Minimal/countsem.c **** detected in any of the tasks. */
  86:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static volatile portBASE_TYPE xErrorDetected = pdFALSE;
  87:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  88:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
  89:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  90:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*
  91:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * The demo task.  This simply counts the semaphore up to its maximum value,
  92:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * the counts it back down again.  The result of each semaphore 'give' and
  93:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * 'take' is inspected, with an error being flagged if it is found not to be
  94:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * the expected result.
  95:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  */
  96:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static void prvCountingSemaphoreTask( void *pvParameters );
  97:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
  98:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*
  99:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * Utility function to increment the semaphore count value up from zero to
 100:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * countMAX_COUNT_VALUE.
 101:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  */
 102:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 103:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 104:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*
 105:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * Utility function to decrement the semaphore count value up from 
 106:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  * countMAX_COUNT_VALUE to zero.
 107:../FreeRTOS/Demo/Common/Minimal/countsem.c ****  */
 108:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 109:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 110:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 111:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 112:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* The structure that is passed into the task as the task parameter. */
 113:../FreeRTOS/Demo/Common/Minimal/countsem.c **** typedef struct COUNT_SEM_STRUCT
 114:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 115:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* The semaphore to be used for the demo. */
 116:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xSemaphoreHandle xSemaphore;
 117:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 118:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Set to countSTART_AT_MAX_COUNT if the semaphore should be created with
 119:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	its count value set to its max count value, or countSTART_AT_ZERO if it
 120:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	should have been created with its count value set to 0. */
 121:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	unsigned portBASE_TYPE uxExpectedStartCount;	
 122:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 123:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Incremented on each cycle of the demo task.  Used to detect a stalled
 124:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	task. */
 125:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	unsigned portBASE_TYPE uxLoopCounter;			
 126:../FreeRTOS/Demo/Common/Minimal/countsem.c **** } xCountSemStruct;
 127:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 128:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /* Two structures are defined, one is passed to each test task. */
 129:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];
 130:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 131:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 132:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 133:../FreeRTOS/Demo/Common/Minimal/countsem.c **** void vStartCountingSemaphoreTasks( void )
 134:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 135:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Create the semaphores that we are going to use for the test/demo.  The
 136:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	first should be created such that it starts at its maximum count value,
 137:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	the second should be created such that it starts with a count value of zero. */
 138:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE
 139:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
 140:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxLoopCounter = 0;
 141:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 142:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
 143:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxExpectedStartCount = 0;
 144:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxLoopCounter = 0;
 145:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 146:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* vQueueAddToRegistry() adds the semaphore to the registry, if one is
 147:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	in use.  The registry is provided as a means for kernel aware 
 148:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	debuggers to locate semaphores and has no purpose if a kernel aware debugger
 149:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 150:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
 151:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	defined to be less than 1. */
 152:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 0 ].xSemaphore, ( signed portCHAR * ) "Counting
 153:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 1 ].xSemaphore, ( signed portCHAR * ) "Counting
 154:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 155:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 156:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Were the semaphores created? */
 157:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
 158:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 159:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
 160:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT1", configMINIMAL_STACK_SIZE, ( 
 161:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT2", configMINIMAL_STACK_SIZE, ( 
 162:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 163:../FreeRTOS/Demo/Common/Minimal/countsem.c **** }
 164:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 165:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 166:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 167:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
  26              		.loc 1 167 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 24
  34              		.cfi_offset 14, -4
  35              		.cfi_offset 8, -8
  36              		.cfi_offset 7, -12
  37              		.cfi_offset 6, -16
  38              		.cfi_offset 5, -20
  39              		.cfi_offset 4, -24
  40              		.loc 1 167 0
  41 0004 0C46     		mov	r4, r1
 168:../FreeRTOS/Demo/Common/Minimal/countsem.c **** unsigned portBASE_TYPE ux;
 169:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 170:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* If the semaphore count is at its maximum then we should not be able to
 171:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	'give' the semaphore. */
 172:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreGive( xSemaphore ) == pdPASS )
  42              		.loc 1 172 0
  43 0006 0021     		movs	r1, #0
  44              	.LVL1:
  45 0008 0B46     		mov	r3, r1
  46 000a 0A46     		mov	r2, r1
 167:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
  47              		.loc 1 167 0
  48 000c 0646     		mov	r6, r0
  49              		.loc 1 172 0
  50 000e FFF7FEFF 		bl	xQueueGenericSend
  51              	.LVL2:
  52 0012 0128     		cmp	r0, #1
 173:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 174:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
  53              		.loc 1 174 0
  54 0014 04BF     		itt	eq
  55 0016 40F20003 		movweq	r3, #:lower16:.LANCHOR0
  56 001a C0F20003 		movteq	r3, #:upper16:.LANCHOR0
 175:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 176:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 177:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
 178:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 179:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 180:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
 181:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		{
 182:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			/* We expected to be able to take the semaphore. */
 183:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
  57              		.loc 1 183 0
  58 001e 40F20007 		movw	r7, #:lower16:.LANCHOR0
 174:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
  59              		.loc 1 174 0
  60 0022 08BF     		it	eq
  61 0024 1860     		streq	r0, [r3, #0]
  62              	.LVL3:
  63              		.loc 1 183 0
  64 0026 C0F20007 		movt	r7, #:upper16:.LANCHOR0
 167:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
  65              		.loc 1 167 0
  66 002a C825     		movs	r5, #200
  67              		.loc 1 183 0
  68 002c 4FF00108 		mov	r8, #1
  69              	.LVL4:
  70              	.L4:
 180:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
  71              		.loc 1 180 0
  72 0030 0021     		movs	r1, #0
  73 0032 0A46     		mov	r2, r1
  74 0034 0B46     		mov	r3, r1
  75 0036 3046     		mov	r0, r6
  76 0038 FFF7FEFF 		bl	xQueueGenericReceive
 184:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		}
 185:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 186:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
  77              		.loc 1 186 0
  78 003c D4F800C0 		ldr	ip, [r4, #0]
 180:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
  79              		.loc 1 180 0
  80 0040 0021     		movs	r1, #0
  81              		.loc 1 186 0
  82 0042 013D     		subs	r5, r5, #1
  83 0044 0CF1010E 		add	lr, ip, #1
 180:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
  84              		.loc 1 180 0
  85 0048 0128     		cmp	r0, #1
  86 004a 0A46     		mov	r2, r1
 183:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
  87              		.loc 1 183 0
  88 004c 18BF     		it	ne
  89 004e C7F80080 		strne	r8, [r7, #0]
 180:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
  90              		.loc 1 180 0
  91 0052 0B46     		mov	r3, r1
  92 0054 3046     		mov	r0, r6
  93              		.loc 1 186 0
  94 0056 C4F800E0 		str	lr, [r4, #0]
 180:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
  95              		.loc 1 180 0
  96 005a FFF7FEFF 		bl	xQueueGenericReceive
  97              		.loc 1 186 0
  98 005e 2268     		ldr	r2, [r4, #0]
 180:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
  99              		.loc 1 180 0
 100 0060 0128     		cmp	r0, #1
 183:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 101              		.loc 1 183 0
 102 0062 18BF     		it	ne
 103 0064 C7F80080 		strne	r8, [r7, #0]
 104              		.loc 1 186 0
 105 0068 501C     		adds	r0, r2, #1
 178:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 106              		.loc 1 178 0
 107 006a 013D     		subs	r5, r5, #1
 108              		.loc 1 186 0
 109 006c 2060     		str	r0, [r4, #0]
 178:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 110              		.loc 1 178 0
 111 006e DFD1     		bne	.L4
 187:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 188:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 189:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	#if configUSE_PREEMPTION == 0
 190:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		taskYIELD();
 191:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	#endif
 192:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 193:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* If the semaphore count is zero then we should not be able to	'take' 
 194:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	the semaphore. */
 195:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 112              		.loc 1 195 0
 113 0070 2946     		mov	r1, r5
 114 0072 3046     		mov	r0, r6
 115 0074 2A46     		mov	r2, r5
 116 0076 2B46     		mov	r3, r5
 117 0078 FFF7FEFF 		bl	xQueueGenericReceive
 118 007c 0128     		cmp	r0, #1
 196:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 197:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 119              		.loc 1 197 0
 120 007e 02BF     		ittt	eq
 121 0080 40F20001 		movweq	r1, #:lower16:.LANCHOR0
 122 0084 C0F20001 		movteq	r1, #:upper16:.LANCHOR0
 123 0088 0860     		streq	r0, [r1, #0]
 124 008a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 125              		.cfi_endproc
 126              	.LFE1:
 128 008e 00BF     		.section	.text.prvCountingSemaphoreTask,"ax",%progbits
 129              		.align	2
 130              		.thumb
 131              		.thumb_func
 133              	prvCountingSemaphoreTask:
 134              	.LFB3:
 198:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 199:../FreeRTOS/Demo/Common/Minimal/countsem.c **** }
 200:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 201:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 202:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 203:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 204:../FreeRTOS/Demo/Common/Minimal/countsem.c **** unsigned portBASE_TYPE ux;
 205:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 206:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* If the semaphore count is zero then we should not be able to	'take' 
 207:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	the semaphore. */
 208:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 209:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 210:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 211:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 212:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 213:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
 214:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 215:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 216:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 217:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		{
 218:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			/* We expected to be able to take the semaphore. */
 219:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 220:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		}
 221:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 222:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 223:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 224:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 225:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	#if configUSE_PREEMPTION == 0
 226:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		taskYIELD();
 227:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	#endif
 228:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 229:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* If the semaphore count is at its maximum then we should not be able to
 230:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	'give' the semaphore. */
 231:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 232:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 233:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 234:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 235:../FreeRTOS/Demo/Common/Minimal/countsem.c **** }
 236:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 237:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 238:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static void prvCountingSemaphoreTask( void *pvParameters )
 239:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 135              		.loc 1 239 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139              	.LVL5:
 140 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 141              	.LCFI1:
 142              		.cfi_def_cfa_offset 32
 143              		.cfi_offset 14, -4
 144              		.cfi_offset 9, -8
 145              		.cfi_offset 8, -12
 146              		.cfi_offset 7, -16
 147              		.cfi_offset 6, -20
 148              		.cfi_offset 5, -24
 149              		.cfi_offset 4, -28
 150              		.cfi_offset 3, -32
 240:../FreeRTOS/Demo/Common/Minimal/countsem.c **** xCountSemStruct *pxParameter;
 241:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 242:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	#ifdef USE_STDIO
 243:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	void vPrintDisplayMessage( const portCHAR * const * ppcMessageToSend );
 244:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	
 245:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		const portCHAR * const pcTaskStartMsg = "Counting semaphore demo started.\r\n";
 246:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 247:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		/* Queue a message for printing to say the task has started. */
 248:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		vPrintDisplayMessage( &pcTaskStartMsg );
 249:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	#endif
 250:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 251:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* The semaphore to be used was passed as the parameter. */
 252:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	pxParameter = ( xCountSemStruct * ) pvParameters;
 253:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 254:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Did we expect to find the semaphore already at its max count value, or
 255:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	at zero? */
 256:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
 151              		.loc 1 256 0
 152 0004 4368     		ldr	r3, [r0, #4]
 239:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 153              		.loc 1 239 0
 154 0006 0446     		mov	r4, r0
 155              	.LVL6:
 156              		.loc 1 256 0
 157 0008 AA2B     		cmp	r3, #170
 257:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 258:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 158              		.loc 1 258 0
 159 000a 00F10809 		add	r9, r0, #8
 256:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
 160              		.loc 1 256 0
 161 000e 03D1     		bne	.L13
 162              	.LVL7:
 163              		.loc 1 258 0
 164 0010 0068     		ldr	r0, [r0, #0]
 165              	.LVL8:
 166 0012 4946     		mov	r1, r9
 167 0014 FFF7FEFF 		bl	prvDecrementSemaphoreCount
 168              	.L13:
 259:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 260:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 261:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Now we expect the semaphore count to be 0, so this time there is an
 262:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	error if we can take the semaphore. */
 263:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
 169              		.loc 1 263 0
 170 0018 0021     		movs	r1, #0
 171 001a 2068     		ldr	r0, [r4, #0]
 172 001c 0A46     		mov	r2, r1
 173 001e 0B46     		mov	r3, r1
 174 0020 FFF7FEFF 		bl	xQueueGenericReceive
 264:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 265:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 175              		.loc 1 265 0
 176 0024 40F20007 		movw	r7, #:lower16:.LANCHOR0
 177 0028 C0F20007 		movt	r7, #:upper16:.LANCHOR0
 263:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
 178              		.loc 1 263 0
 179 002c 0128     		cmp	r0, #1
 180              		.loc 1 265 0
 181 002e 08BF     		it	eq
 182 0030 3860     		streq	r0, [r7, #0]
 183              	.LBB4:
 184              	.LBB5:
 219:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 185              		.loc 1 219 0
 186 0032 4FF00108 		mov	r8, #1
 187              	.L28:
 188              	.LBE5:
 189              	.LBE4:
 266:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 267:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 268:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	for( ;; )
 269:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 270:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 190              		.loc 1 270 0 discriminator 1
 191 0036 2668     		ldr	r6, [r4, #0]
 192              	.LVL9:
 193              	.LBB8:
 194              	.LBB6:
 208:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 195              		.loc 1 208 0 discriminator 1
 196 0038 0021     		movs	r1, #0
 197 003a 3046     		mov	r0, r6
 198 003c 0A46     		mov	r2, r1
 199 003e 0B46     		mov	r3, r1
 200 0040 FFF7FEFF 		bl	xQueueGenericReceive
 201              	.LVL10:
 202 0044 0128     		cmp	r0, #1
 210:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 203              		.loc 1 210 0 discriminator 1
 204 0046 08BF     		it	eq
 205 0048 3860     		streq	r0, [r7, #0]
 206              	.LVL11:
 207              	.LBE6:
 208              	.LBE8:
 239:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 209              		.loc 1 239 0 discriminator 1
 210 004a C825     		movs	r5, #200
 211              	.LVL12:
 212              	.L17:
 213              	.LBB9:
 214              	.LBB7:
 216:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 215              		.loc 1 216 0
 216 004c 0021     		movs	r1, #0
 217 004e 0A46     		mov	r2, r1
 218 0050 0B46     		mov	r3, r1
 219 0052 3046     		mov	r0, r6
 220 0054 FFF7FEFF 		bl	xQueueGenericSend
 222:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 221              		.loc 1 222 0
 222 0058 D4F808C0 		ldr	ip, [r4, #8]
 216:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 223              		.loc 1 216 0
 224 005c 0021     		movs	r1, #0
 222:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 225              		.loc 1 222 0
 226 005e 013D     		subs	r5, r5, #1
 227 0060 0CF1010E 		add	lr, ip, #1
 216:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 228              		.loc 1 216 0
 229 0064 0128     		cmp	r0, #1
 230 0066 0A46     		mov	r2, r1
 231 0068 0B46     		mov	r3, r1
 219:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 232              		.loc 1 219 0
 233 006a 18BF     		it	ne
 234 006c C7F80080 		strne	r8, [r7, #0]
 216:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 235              		.loc 1 216 0
 236 0070 3046     		mov	r0, r6
 222:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 237              		.loc 1 222 0
 238 0072 C4F808E0 		str	lr, [r4, #8]
 216:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 239              		.loc 1 216 0
 240 0076 FFF7FEFF 		bl	xQueueGenericSend
 222:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 241              		.loc 1 222 0
 242 007a A168     		ldr	r1, [r4, #8]
 216:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 243              		.loc 1 216 0
 244 007c 0128     		cmp	r0, #1
 219:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 245              		.loc 1 219 0
 246 007e 18BF     		it	ne
 247 0080 C7F80080 		strne	r8, [r7, #0]
 222:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 248              		.loc 1 222 0
 249 0084 481C     		adds	r0, r1, #1
 214:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 250              		.loc 1 214 0
 251 0086 013D     		subs	r5, r5, #1
 222:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 252              		.loc 1 222 0
 253 0088 A060     		str	r0, [r4, #8]
 214:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 254              		.loc 1 214 0
 255 008a DFD1     		bne	.L17
 231:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 256              		.loc 1 231 0
 257 008c 2946     		mov	r1, r5
 258 008e 3046     		mov	r0, r6
 259 0090 2A46     		mov	r2, r5
 260 0092 2B46     		mov	r3, r5
 261 0094 FFF7FEFF 		bl	xQueueGenericSend
 262 0098 0128     		cmp	r0, #1
 233:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 263              		.loc 1 233 0
 264 009a 08BF     		it	eq
 265 009c 3860     		streq	r0, [r7, #0]
 266              	.LBE7:
 267              	.LBE9:
 271:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 268              		.loc 1 271 0
 269 009e 4946     		mov	r1, r9
 270 00a0 2068     		ldr	r0, [r4, #0]
 271 00a2 FFF7FEFF 		bl	prvDecrementSemaphoreCount
 272:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 272              		.loc 1 272 0
 273 00a6 C6E7     		b	.L28
 274              		.cfi_endproc
 275              	.LFE3:
 277              		.section	.text.vStartCountingSemaphoreTasks,"ax",%progbits
 278              		.align	2
 279              		.global	vStartCountingSemaphoreTasks
 280              		.thumb
 281              		.thumb_func
 283              	vStartCountingSemaphoreTasks:
 284              	.LFB0:
 134:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 285              		.loc 1 134 0
 286              		.cfi_startproc
 287              		@ args = 0, pretend = 0, frame = 0
 288              		@ frame_needed = 0, uses_anonymous_args = 0
 289 0000 30B5     		push	{r4, r5, lr}
 290              	.LCFI2:
 291              		.cfi_def_cfa_offset 12
 292              		.cfi_offset 14, -4
 293              		.cfi_offset 5, -8
 294              		.cfi_offset 4, -12
 138:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE
 295              		.loc 1 138 0
 296 0002 C820     		movs	r0, #200
 134:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 297              		.loc 1 134 0
 298 0004 85B0     		sub	sp, sp, #20
 299              	.LCFI3:
 300              		.cfi_def_cfa_offset 32
 138:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE
 301              		.loc 1 138 0
 302 0006 0146     		mov	r1, r0
 303 0008 FFF7FEFF 		bl	xQueueCreateCountingSemaphore
 304 000c 40F20004 		movw	r4, #:lower16:.LANCHOR1
 305 0010 C0F20004 		movt	r4, #:upper16:.LANCHOR1
 140:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxLoopCounter = 0;
 306              		.loc 1 140 0
 307 0014 0025     		movs	r5, #0
 138:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE
 308              		.loc 1 138 0
 309 0016 0346     		mov	r3, r0
 139:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
 310              		.loc 1 139 0
 311 0018 AA22     		movs	r2, #170
 138:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE
 312              		.loc 1 138 0
 313 001a 2360     		str	r3, [r4, #0]
 142:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
 314              		.loc 1 142 0
 315 001c C820     		movs	r0, #200
 139:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
 316              		.loc 1 139 0
 317 001e 6260     		str	r2, [r4, #4]
 142:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
 318              		.loc 1 142 0
 319 0020 2946     		mov	r1, r5
 140:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxLoopCounter = 0;
 320              		.loc 1 140 0
 321 0022 A560     		str	r5, [r4, #8]
 142:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
 322              		.loc 1 142 0
 323 0024 FFF7FEFF 		bl	xQueueCreateCountingSemaphore
 324 0028 E060     		str	r0, [r4, #12]
 143:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxExpectedStartCount = 0;
 325              		.loc 1 143 0
 326 002a 2561     		str	r5, [r4, #16]
 144:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxLoopCounter = 0;
 327              		.loc 1 144 0
 328 002c 6561     		str	r5, [r4, #20]
 157:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
 329              		.loc 1 157 0
 330 002e 2368     		ldr	r3, [r4, #0]
 331 0030 002B     		cmp	r3, #0
 332 0032 25D0     		beq	.L33
 333              	.L31:
 160:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT1", configMINIMAL_STACK_SIZE, ( 
 334              		.loc 1 160 0
 335 0034 40F20000 		movw	r0, #:lower16:prvCountingSemaphoreTask
 336 0038 40F20001 		movw	r1, #:lower16:.LC0
 337 003c 40F20003 		movw	r3, #:lower16:.LANCHOR1
 338 0040 0024     		movs	r4, #0
 339 0042 C0F20001 		movt	r1, #:upper16:.LC0
 340 0046 7822     		movs	r2, #120
 341 0048 C0F20003 		movt	r3, #:upper16:.LANCHOR1
 342 004c C0F20000 		movt	r0, #:upper16:prvCountingSemaphoreTask
 343 0050 0094     		str	r4, [sp, #0]
 344 0052 0194     		str	r4, [sp, #4]
 345 0054 0294     		str	r4, [sp, #8]
 346 0056 0394     		str	r4, [sp, #12]
 347 0058 FFF7FEFF 		bl	xTaskGenericCreate
 161:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT2", configMINIMAL_STACK_SIZE, ( 
 348              		.loc 1 161 0
 349 005c 40F20000 		movw	r0, #:lower16:prvCountingSemaphoreTask
 350 0060 40F20001 		movw	r1, #:lower16:.LC1
 351 0064 C0F20000 		movt	r0, #:upper16:prvCountingSemaphoreTask
 352 0068 C0F20001 		movt	r1, #:upper16:.LC1
 353 006c 7822     		movs	r2, #120
 354 006e 064B     		ldr	r3, .L34
 355 0070 0094     		str	r4, [sp, #0]
 356 0072 0194     		str	r4, [sp, #4]
 357 0074 0294     		str	r4, [sp, #8]
 358 0076 0394     		str	r4, [sp, #12]
 359 0078 FFF7FEFF 		bl	xTaskGenericCreate
 360              	.L30:
 163:../FreeRTOS/Demo/Common/Minimal/countsem.c **** }
 361              		.loc 1 163 0
 362 007c 05B0     		add	sp, sp, #20
 363 007e 30BD     		pop	{r4, r5, pc}
 364              	.L33:
 157:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
 365              		.loc 1 157 0 discriminator 1
 366 0080 E068     		ldr	r0, [r4, #12]
 367 0082 0028     		cmp	r0, #0
 368 0084 D6D1     		bne	.L31
 369 0086 F9E7     		b	.L30
 370              	.L35:
 371              		.align	2
 372              	.L34:
 373 0088 0C000000 		.word	.LANCHOR1+12
 374              		.cfi_endproc
 375              	.LFE0:
 377              		.section	.text.xAreCountingSemaphoreTasksStillRunning,"ax",%progbits
 378              		.align	2
 379              		.global	xAreCountingSemaphoreTasksStillRunning
 380              		.thumb
 381              		.thumb_func
 383              	xAreCountingSemaphoreTasksStillRunning:
 384              	.LFB4:
 273:../FreeRTOS/Demo/Common/Minimal/countsem.c **** }
 274:../FreeRTOS/Demo/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 275:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 276:../FreeRTOS/Demo/Common/Minimal/countsem.c **** portBASE_TYPE xAreCountingSemaphoreTasksStillRunning( void )
 277:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 385              		.loc 1 277 0
 386              		.cfi_startproc
 387              		@ args = 0, pretend = 0, frame = 0
 388              		@ frame_needed = 0, uses_anonymous_args = 0
 389              		@ link register save eliminated.
 390              	.LVL13:
 278:../FreeRTOS/Demo/Common/Minimal/countsem.c **** static unsigned portBASE_TYPE uxLastCount0 = 0, uxLastCount1 = 0;
 279:../FreeRTOS/Demo/Common/Minimal/countsem.c **** portBASE_TYPE xReturn = pdPASS;
 280:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 281:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Return fail if any 'give' or 'take' did not result in the expected
 282:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	behaviour. */
 283:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xErrorDetected != pdFALSE )
 391              		.loc 1 283 0
 392 0000 40F20000 		movw	r0, #:lower16:.LANCHOR0
 284:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 285:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 286:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 287:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 288:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	/* Return fail if either task is not still incrementing its loop counter. */
 289:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
 393              		.loc 1 289 0
 394 0004 40F20003 		movw	r3, #:lower16:.LANCHOR1
 395 0008 40F20002 		movw	r2, #:lower16:.LANCHOR2
 283:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xErrorDetected != pdFALSE )
 396              		.loc 1 283 0
 397 000c C0F20000 		movt	r0, #:upper16:.LANCHOR0
 398              		.loc 1 289 0
 399 0010 C0F20003 		movt	r3, #:upper16:.LANCHOR1
 400 0014 C0F20002 		movt	r2, #:upper16:.LANCHOR2
 277:../FreeRTOS/Demo/Common/Minimal/countsem.c **** {
 401              		.loc 1 277 0
 402 0018 10B4     		push	{r4}
 403              	.LCFI4:
 404              		.cfi_def_cfa_offset 4
 405              		.cfi_offset 4, -4
 283:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( xErrorDetected != pdFALSE )
 406              		.loc 1 283 0
 407 001a 0068     		ldr	r0, [r0, #0]
 408              	.LVL14:
 409              		.loc 1 289 0
 410 001c 1168     		ldr	r1, [r2, #0]
 411 001e 9C68     		ldr	r4, [r3, #8]
 412 0020 8C42     		cmp	r4, r1
 413 0022 16D0     		beq	.L39
 290:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 291:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 292:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 293:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	else
 294:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 295:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
 414              		.loc 1 295 0
 415 0024 9968     		ldr	r1, [r3, #8]
 279:../FreeRTOS/Demo/Common/Minimal/countsem.c **** portBASE_TYPE xReturn = pdPASS;
 416              		.loc 1 279 0
 417 0026 D0F10100 		rsbs	r0, r0, #1
 418              	.LVL15:
 419 002a 38BF     		it	cc
 420 002c 0020     		movcc	r0, #0
 421              		.loc 1 295 0
 422 002e 1160     		str	r1, [r2, #0]
 423              	.L37:
 424              	.LVL16:
 296:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 297:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 298:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
 425              		.loc 1 298 0
 426 0030 40F20002 		movw	r2, #:lower16:.LANCHOR3
 427 0034 C0F20002 		movt	r2, #:upper16:.LANCHOR3
 428 0038 5C69     		ldr	r4, [r3, #20]
 429 003a 1168     		ldr	r1, [r2, #0]
 430 003c 40F20003 		movw	r3, #:lower16:.LANCHOR1
 431 0040 8C42     		cmp	r4, r1
 432 0042 C0F20003 		movt	r3, #:upper16:.LANCHOR1
 299:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 300:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 301:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 302:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	else
 303:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	{
 304:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
 433              		.loc 1 304 0
 434 0046 1ABF     		itte	ne
 435 0048 5B69     		ldrne	r3, [r3, #20]
 436 004a 1360     		strne	r3, [r2, #0]
 300:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 437              		.loc 1 300 0
 438 004c 0020     		moveq	r0, #0
 439              	.LVL17:
 305:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	}
 306:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 
 307:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 	return xReturn;
 308:../FreeRTOS/Demo/Common/Minimal/countsem.c **** }
 440              		.loc 1 308 0
 441 004e 10BC     		pop	{r4}
 442 0050 7047     		bx	lr
 443              	.LVL18:
 444              	.L39:
 291:../FreeRTOS/Demo/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 445              		.loc 1 291 0
 446 0052 0020     		movs	r0, #0
 447              	.LVL19:
 448 0054 ECE7     		b	.L37
 449              		.cfi_endproc
 450              	.LFE4:
 452 0056 00BF     		.section	.bss.xParameters,"aw",%nobits
 453              		.align	2
 454              		.set	.LANCHOR1,. + 0
 457              	xParameters:
 458 0000 00000000 		.space	24
 458      00000000 
 458      00000000 
 458      00000000 
 458      00000000 
 459              		.section	.rodata.str1.4,"aMS",%progbits,1
 460              		.align	2
 461              	.LC0:
 462 0000 434E5431 		.ascii	"CNT1\000"
 462      00
 463 0005 000000   		.space	3
 464              	.LC1:
 465 0008 434E5432 		.ascii	"CNT2\000"
 465      00
 466 000d 000000   		.section	.bss.uxLastCount1.4226,"aw",%nobits
 467              		.align	2
 468              		.set	.LANCHOR3,. + 0
 471              	uxLastCount1.4226:
 472 0000 00000000 		.space	4
 473              		.section	.bss.xErrorDetected,"aw",%nobits
 474              		.align	2
 475              		.set	.LANCHOR0,. + 0
 478              	xErrorDetected:
 479 0000 00000000 		.space	4
 480              		.section	.bss.uxLastCount0.4225,"aw",%nobits
 481              		.align	2
 482              		.set	.LANCHOR2,. + 0
 485              	uxLastCount0.4225:
 486 0000 00000000 		.space	4
 487              		.text
 488              	.Letext0:
 489              		.file 2 "../FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM3/portmacro.h"
 490              		.file 3 "../FreeRTOS/Source/include/queue.h"
 491              		.file 4 "../FreeRTOS/Source/include/semphr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 countsem.c
     /tmp/cch1PfJa.s:19     .text.prvDecrementSemaphoreCount:00000000 $t
     /tmp/cch1PfJa.s:23     .text.prvDecrementSemaphoreCount:00000000 prvDecrementSemaphoreCount
     /tmp/cch1PfJa.s:475    .bss.xErrorDetected:00000000 .LANCHOR0
     /tmp/cch1PfJa.s:129    .text.prvCountingSemaphoreTask:00000000 $t
     /tmp/cch1PfJa.s:133    .text.prvCountingSemaphoreTask:00000000 prvCountingSemaphoreTask
     /tmp/cch1PfJa.s:278    .text.vStartCountingSemaphoreTasks:00000000 $t
     /tmp/cch1PfJa.s:283    .text.vStartCountingSemaphoreTasks:00000000 vStartCountingSemaphoreTasks
     /tmp/cch1PfJa.s:454    .bss.xParameters:00000000 .LANCHOR1
     /tmp/cch1PfJa.s:461    .rodata.str1.4:00000000 .LC0
     /tmp/cch1PfJa.s:464    .rodata.str1.4:00000008 .LC1
     /tmp/cch1PfJa.s:373    .text.vStartCountingSemaphoreTasks:00000088 $d
     /tmp/cch1PfJa.s:378    .text.xAreCountingSemaphoreTasksStillRunning:00000000 $t
     /tmp/cch1PfJa.s:383    .text.xAreCountingSemaphoreTasksStillRunning:00000000 xAreCountingSemaphoreTasksStillRunning
     /tmp/cch1PfJa.s:482    .bss.uxLastCount0.4225:00000000 .LANCHOR2
     /tmp/cch1PfJa.s:468    .bss.uxLastCount1.4226:00000000 .LANCHOR3
     /tmp/cch1PfJa.s:453    .bss.xParameters:00000000 $d
     /tmp/cch1PfJa.s:457    .bss.xParameters:00000000 xParameters
     /tmp/cch1PfJa.s:460    .rodata.str1.4:00000000 $d
     /tmp/cch1PfJa.s:467    .bss.uxLastCount1.4226:00000000 $d
     /tmp/cch1PfJa.s:471    .bss.uxLastCount1.4226:00000000 uxLastCount1.4226
     /tmp/cch1PfJa.s:474    .bss.xErrorDetected:00000000 $d
     /tmp/cch1PfJa.s:478    .bss.xErrorDetected:00000000 xErrorDetected
     /tmp/cch1PfJa.s:481    .bss.uxLastCount0.4225:00000000 $d
     /tmp/cch1PfJa.s:485    .bss.uxLastCount0.4225:00000000 uxLastCount0.4225
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueGenericSend
xQueueGenericReceive
xQueueCreateCountingSemaphore
xTaskGenericCreate
