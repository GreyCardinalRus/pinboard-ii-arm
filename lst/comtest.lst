   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"comtest.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.vComRxTask,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	vComRxTask:
  24              	.LFB2:
  25              		.file 1 "../FreeRTOS/Demo/Common/Minimal/comtest.c"
   1:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /*
   2:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	
   4:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
   5:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     ***************************************************************************
   6:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *                                                                       *
   7:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    available.                                                         *
  10:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *                                                                       *
  11:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *                                                                       *
  18:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *                                                                       *
  20:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Demo/Common/Minimal/comtest.c ****      *                                                                       *
  22:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     ***************************************************************************
  23:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  24:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  25:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  27:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  42:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  44:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     contact details.
  46:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  47:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     critical systems.
  49:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  50:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Demo/Common/Minimal/comtest.c ****     licensing and training services.
  52:../FreeRTOS/Demo/Common/Minimal/comtest.c **** */
  53:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  54:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  55:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /*
  56:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * This version of comtest. c is for use on systems that have limited stack
  57:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * space and no display facilities.  The complete version can be found in
  58:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * the Demo/Common/Full directory.
  59:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  *
  60:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * Creates two tasks that operate on an interrupt driven serial port.  A
  61:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * loopback connector should be used so that everything that is transmitted is
  62:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * also received.  The serial port does not use any flow control.  On a
  63:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * standard 9way 'D' connector pins two and three should be connected together.
  64:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  *
  65:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * The first task posts a sequence of characters to the Tx queue, toggling an
  66:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * LED on each successful post.  At the end of the sequence it sleeps for a
  67:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * pseudo-random period before resending the same sequence.
  68:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  *
  69:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * The UART Tx end interrupt is enabled whenever data is available in the Tx
  70:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * queue.  The Tx end ISR removes a single character from the Tx queue and
  71:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * passes it to the UART for transmission.
  72:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  *
  73:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * The second task blocks on the Rx queue waiting for a character to become
  74:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * available.  When the UART Rx end interrupt receives a character it places
  75:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * it in the Rx queue, waking the second task.  The second task checks that the
  76:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * characters removed from the Rx queue form the same sequence as those posted
  77:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * to the Tx queue, and toggles an LED for each correct character.
  78:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  *
  79:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * The receiving task is spawned with a higher priority than the transmitting
  80:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * task.  The receiver will therefore wake every time a character is
  81:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * transmitted so neither the Tx or Rx queue should ever hold more than a few
  82:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  * characters.
  83:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  *
  84:../FreeRTOS/Demo/Common/Minimal/comtest.c ****  */
  85:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  86:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* Scheduler include files. */
  87:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #include <stdlib.h>
  88:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #include "FreeRTOS.h"
  89:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #include "task.h"
  90:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  91:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* Demo program include files. */
  92:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #include "serial.h"
  93:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #include "comtest.h"
  94:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #include "partest.h"
  95:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
  96:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comSTACK_SIZE				configMINIMAL_STACK_SIZE
  97:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comTX_LED_OFFSET			( 0 )
  98:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comRX_LED_OFFSET			( 1 )
  99:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comTOTAL_PERMISSIBLE_ERRORS ( 2 )
 100:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 101:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* The Tx task will transmit the sequence of characters at a pseudo random
 102:../FreeRTOS/Demo/Common/Minimal/comtest.c **** interval.  This is the maximum and minimum block time between sends. */
 103:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comTX_MAX_BLOCK_TIME		( ( portTickType ) 0x96 )
 104:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comTX_MIN_BLOCK_TIME		( ( portTickType ) 0x32 )
 105:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comOFFSET_TIME				( ( portTickType ) 3 )
 106:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 107:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* We should find that each character can be queued for Tx immediately and we
 108:../FreeRTOS/Demo/Common/Minimal/comtest.c **** don't have to block to send. */
 109:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comNO_BLOCK					( ( portTickType ) 0 )
 110:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 111:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* The Rx task will block on the Rx queue for a long period. */
 112:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comRX_BLOCK_TIME			( ( portTickType ) 0xffff )
 113:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 114:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* The sequence transmitted is from comFIRST_BYTE to and including comLAST_BYTE. */
 115:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comFIRST_BYTE				( 'A' )
 116:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comLAST_BYTE				( 'X' )
 117:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 118:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comBUFFER_LEN				( ( unsigned portBASE_TYPE ) ( comLAST_BYTE - comFIRST_BYTE ) + ( unsigned
 119:../FreeRTOS/Demo/Common/Minimal/comtest.c **** #define comINITIAL_RX_COUNT_VALUE	( 0 )
 120:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 121:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* Handle to the com port used by both tasks. */
 122:../FreeRTOS/Demo/Common/Minimal/comtest.c **** static xComPortHandle xPort = NULL;
 123:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 124:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* The transmit task as described at the top of the file. */
 125:../FreeRTOS/Demo/Common/Minimal/comtest.c **** static portTASK_FUNCTION_PROTO( vComTxTask, pvParameters );
 126:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 127:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* The receive task as described at the top of the file. */
 128:../FreeRTOS/Demo/Common/Minimal/comtest.c **** static portTASK_FUNCTION_PROTO( vComRxTask, pvParameters );
 129:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 130:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* The LED that should be toggled by the Rx and Tx tasks.  The Rx task will
 131:../FreeRTOS/Demo/Common/Minimal/comtest.c **** toggle LED ( uxBaseLED + comRX_LED_OFFSET).  The Tx task will toggle LED
 132:../FreeRTOS/Demo/Common/Minimal/comtest.c **** ( uxBaseLED + comTX_LED_OFFSET ). */
 133:../FreeRTOS/Demo/Common/Minimal/comtest.c **** static unsigned portBASE_TYPE uxBaseLED = 0;
 134:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 135:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /* Check variable used to ensure no error have occurred.  The Rx task will
 136:../FreeRTOS/Demo/Common/Minimal/comtest.c **** increment this variable after every successfully received sequence.  If at any
 137:../FreeRTOS/Demo/Common/Minimal/comtest.c **** time the sequence is incorrect the the variable will stop being incremented. */
 138:../FreeRTOS/Demo/Common/Minimal/comtest.c **** static volatile unsigned portBASE_TYPE uxRxLoops = comINITIAL_RX_COUNT_VALUE;
 139:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 140:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /*-----------------------------------------------------------*/
 141:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 142:../FreeRTOS/Demo/Common/Minimal/comtest.c **** void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned p
 143:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
 144:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	/* Initialise the com port then spawn the Rx and Tx tasks. */
 145:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	uxBaseLED = uxLED;
 146:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
 147:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 148:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	/* The Tx task is spawned with a lower priority than the Rx task. */
 149:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	xTaskCreate( vComTxTask, ( signed char * ) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHa
 150:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle
 151:../FreeRTOS/Demo/Common/Minimal/comtest.c **** }
 152:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /*-----------------------------------------------------------*/
 153:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 154:../FreeRTOS/Demo/Common/Minimal/comtest.c **** static portTASK_FUNCTION( vComTxTask, pvParameters )
 155:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
 156:../FreeRTOS/Demo/Common/Minimal/comtest.c **** signed char cByteToSend;
 157:../FreeRTOS/Demo/Common/Minimal/comtest.c **** portTickType xTimeToWait;
 158:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 159:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	/* Just to stop compiler warnings. */
 160:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	( void ) pvParameters;
 161:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 162:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	for( ;; )
 163:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	{
 164:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* Simply transmit a sequence of characters from comFIRST_BYTE to
 165:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		comLAST_BYTE. */
 166:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 167:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		{
 168:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
 169:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			{
 170:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
 171:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			}
 172:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		}
 173:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 174:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* Turn the LED off while we are not doing anything. */
 175:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
 176:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 177:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* We have posted all the characters in the string - wait before
 178:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		re-sending.  Wait a pseudo-random time as this will provide a better
 179:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		test. */
 180:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
 181:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 182:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* Make sure we don't wait too long... */
 183:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xTimeToWait %= comTX_MAX_BLOCK_TIME;
 184:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 185:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* ...but we do want to wait. */
 186:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
 187:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		{
 188:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			xTimeToWait = comTX_MIN_BLOCK_TIME;
 189:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		}
 190:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 191:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		vTaskDelay( xTimeToWait );
 192:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	}
 193:../FreeRTOS/Demo/Common/Minimal/comtest.c **** } /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
 194:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /*-----------------------------------------------------------*/
 195:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 196:../FreeRTOS/Demo/Common/Minimal/comtest.c **** static portTASK_FUNCTION( vComRxTask, pvParameters )
 197:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
  26              		.loc 1 197 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 20
  34              		.cfi_offset 14, -4
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 6, -12
  37              		.cfi_offset 5, -16
  38              		.cfi_offset 4, -20
  39 0002 40F20005 		movw	r5, #:lower16:.LANCHOR0
  40 0006 40F20007 		movw	r7, #:lower16:.LANCHOR1
  41 000a 83B0     		sub	sp, sp, #12
  42              	.LCFI1:
  43              		.cfi_def_cfa_offset 32
 198:../FreeRTOS/Demo/Common/Minimal/comtest.c **** signed char cExpectedByte, cByteRxed;
 199:../FreeRTOS/Demo/Common/Minimal/comtest.c **** portBASE_TYPE xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
  44              		.loc 1 199 0
  45 000c 0026     		movs	r6, #0
  46 000e C0F20005 		movt	r5, #:upper16:.LANCHOR0
  47 0012 C0F20007 		movt	r7, #:upper16:.LANCHOR1
  48              	.LVL1:
  49              	.L17:
 200:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 201:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	/* Just to stop compiler warnings. */
 202:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	( void ) pvParameters;
 203:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 204:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	for( ;; )
 205:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	{
 206:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* We expect to receive the characters from comFIRST_BYTE to
 207:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
 208:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
  50              		.loc 1 208 0
  51 0016 4124     		movs	r4, #65
  52              	.LVL2:
  53              	.L5:
 209:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		{
 210:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			/* Block on the queue that contains received bytes until a byte is
 211:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			available. */
 212:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
  54              		.loc 1 212 0
  55 0018 0DF10701 		add	r1, sp, #7
  56              	.LVL3:
  57 001c 4FF6FF72 		movw	r2, #65535
  58 0020 0020     		movs	r0, #0
  59 0022 FFF7FEFF 		bl	xSerialGetChar
  60 0026 38B1     		cbz	r0, .L3
 213:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			{
 214:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				/* Was this the byte we were expecting?  If so, toggle the LED,
 215:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				otherwise we are out on sync and should break out of the loop
 216:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				until the expected character sequence is about to restart. */
 217:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				if( cByteRxed == cExpectedByte )
  61              		.loc 1 217 0
  62 0028 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
  63 002c 9C42     		cmp	r4, r3
  64 002e 24D1     		bne	.L4
 218:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				{
 219:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
  65              		.loc 1 219 0
  66 0030 2868     		ldr	r0, [r5, #0]
  67 0032 0130     		adds	r0, r0, #1
  68 0034 FFF7FEFF 		bl	vParTestToggleLED
  69              	.L3:
 208:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
  70              		.loc 1 208 0
  71 0038 0134     		adds	r4, r4, #1
 212:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
  72              		.loc 1 212 0
  73 003a 0DF10701 		add	r1, sp, #7
  74 003e 4FF6FF72 		movw	r2, #65535
  75 0042 0020     		movs	r0, #0
 208:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
  76              		.loc 1 208 0
  77 0044 E4B2     		uxtb	r4, r4
 212:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
  78              		.loc 1 212 0
  79 0046 FFF7FEFF 		bl	xSerialGetChar
  80 004a 38B1     		cbz	r0, .L14
 217:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				if( cByteRxed == cExpectedByte )
  81              		.loc 1 217 0
  82 004c 9DF80710 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
  83 0050 8C42     		cmp	r4, r1
  84 0052 12D1     		bne	.L4
  85              		.loc 1 219 0
  86 0054 2A68     		ldr	r2, [r5, #0]
  87 0056 501C     		adds	r0, r2, #1
  88 0058 FFF7FEFF 		bl	vParTestToggleLED
  89              	.L14:
 208:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
  90              		.loc 1 208 0
  91 005c 631C     		adds	r3, r4, #1
  92 005e DCB2     		uxtb	r4, r3
  93              	.LVL4:
  94 0060 592C     		cmp	r4, #89
  95 0062 D9D1     		bne	.L5
 220:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				}
 221:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				else
 222:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				{
 223:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 					xResyncRequired = pdTRUE;
 224:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 					break; /*lint !e960 Non-switch break allowed. */
 225:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				}
 226:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			}
 227:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		}
 228:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 229:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* Turn the LED off while we are not doing anything. */
 230:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
  96              		.loc 1 230 0
  97 0064 2C68     		ldr	r4, [r5, #0]
  98              	.LVL5:
  99 0066 0021     		movs	r1, #0
 100 0068 601C     		adds	r0, r4, #1
 101 006a FFF7FEFF 		bl	vParTestSetLED
 231:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 232:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		/* Did we break out of the loop because the characters were received in
 233:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		an unexpected order?  If so wait here until the character sequence is
 234:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		about to restart. */
 235:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		if( xResyncRequired == pdTRUE )
 236:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		{
 237:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			while( cByteRxed != comLAST_BYTE )
 238:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			{
 239:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				/* Block until the next char is available. */
 240:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
 241:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			}
 242:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 243:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			/* Note that an error occurred which caused us to have to resync.
 244:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			We use this to stop incrementing the loop counter so
 245:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			sAreComTestTasksStillRunning() will return false - indicating an
 246:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			error. */
 247:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			xErrorOccurred++;
 248:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 249:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			/* We have now resynced with the Tx task and can continue. */
 250:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			xResyncRequired = pdFALSE;
 251:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		}
 252:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		else
 253:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		{
 254:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
 102              		.loc 1 254 0
 103 006e 012E     		cmp	r6, #1
 104 0070 D1DC     		bgt	.L17
 255:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			{
 256:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				/* Increment the count of successful loops.  As error
 257:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				occurring (i.e. an unexpected character being received) will
 258:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				prevent this counter being incremented for the rest of the
 259:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				execution.   Don't worry about mutual exclusion on this
 260:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				variable - it doesn't really matter as we just want it
 261:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				to change. */
 262:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				uxRxLoops++;
 105              		.loc 1 262 0
 106 0072 3868     		ldr	r0, [r7, #0]
 107 0074 431C     		adds	r3, r0, #1
 108 0076 3B60     		str	r3, [r7, #0]
 109 0078 CDE7     		b	.L17
 110              	.L4:
 111              	.LVL6:
 230:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
 112              		.loc 1 230 0
 113 007a 2A68     		ldr	r2, [r5, #0]
 114 007c 0021     		movs	r1, #0
 115 007e 501C     		adds	r0, r2, #1
 116 0080 FFF7FEFF 		bl	vParTestSetLED
 237:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			while( cByteRxed != comLAST_BYTE )
 117              		.loc 1 237 0
 118 0084 9DF90710 		ldrsb	r1, [sp, #7]
 119              	.LVL7:
 120 0088 5829     		cmp	r1, #88
 121              	.LVL8:
 122 008a 0BD0     		beq	.L7
 123              	.L11:
 240:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
 124              		.loc 1 240 0
 125 008c 0020     		movs	r0, #0
 126 008e 0DF10701 		add	r1, sp, #7
 127              	.LVL9:
 128 0092 4FF6FF72 		movw	r2, #65535
 129 0096 FFF7FEFF 		bl	xSerialGetChar
 130              	.LVL10:
 237:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			while( cByteRxed != comLAST_BYTE )
 131              		.loc 1 237 0
 132 009a 9DF907C0 		ldrsb	ip, [sp, #7]
 133              	.LVL11:
 134 009e BCF1580F 		cmp	ip, #88
 135              	.LVL12:
 136 00a2 F3D1     		bne	.L11
 137              	.L7:
 247:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			xErrorOccurred++;
 138              		.loc 1 247 0
 139 00a4 0136     		adds	r6, r6, #1
 140              	.LVL13:
 141 00a6 B6E7     		b	.L17
 142              		.cfi_endproc
 143              	.LFE2:
 145              		.section	.text.vComTxTask,"ax",%progbits
 146              		.align	2
 147              		.thumb
 148              		.thumb_func
 150              	vComTxTask:
 151              	.LFB1:
 155:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
 152              		.loc 1 155 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 0
 155              		@ frame_needed = 0, uses_anonymous_args = 0
 156              	.LVL14:
 157 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 158              	.LCFI2:
 159              		.cfi_def_cfa_offset 24
 160              		.cfi_offset 14, -4
 161              		.cfi_offset 7, -8
 162              		.cfi_offset 6, -12
 163              		.cfi_offset 5, -16
 164              		.cfi_offset 4, -20
 165              		.cfi_offset 3, -24
 166 0002 40F20005 		movw	r5, #:lower16:.LANCHOR0
 183:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xTimeToWait %= comTX_MAX_BLOCK_TIME;
 167              		.loc 1 183 0
 168 0006 48F2B516 		movw	r6, #33205
 166:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 169              		.loc 1 166 0
 170 000a 4124     		movs	r4, #65
 171 000c C0F20005 		movt	r5, #:upper16:.LANCHOR0
 183:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xTimeToWait %= comTX_MAX_BLOCK_TIME;
 172              		.loc 1 183 0
 173 0010 C1F64E36 		movt	r6, 6990
 174 0014 9627     		movs	r7, #150
 175 0016 01E0     		b	.L27
 176              	.LVL15:
 177              	.L22:
 166:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 178              		.loc 1 166 0
 179 0018 0134     		adds	r4, r4, #1
 180              	.LVL16:
 181 001a E4B2     		uxtb	r4, r4
 182              	.LVL17:
 183              	.L27:
 166:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 184              		.loc 1 166 0 is_stmt 0 discriminator 1
 185 001c 63B2     		sxtb	r3, r4
 168:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
 186              		.loc 1 168 0 is_stmt 1 discriminator 1
 187 001e 0020     		movs	r0, #0
 166:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 188              		.loc 1 166 0 discriminator 1
 189 0020 582B     		cmp	r3, #88
 168:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
 190              		.loc 1 168 0 discriminator 1
 191 0022 0246     		mov	r2, r0
 192 0024 1946     		mov	r1, r3
 166:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 193              		.loc 1 166 0 discriminator 1
 194 0026 07DC     		bgt	.L28
 168:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
 195              		.loc 1 168 0
 196 0028 FFF7FEFF 		bl	xSerialPutChar
 197 002c 0128     		cmp	r0, #1
 198 002e F3D1     		bne	.L22
 170:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
 199              		.loc 1 170 0
 200 0030 2868     		ldr	r0, [r5, #0]
 201 0032 FFF7FEFF 		bl	vParTestToggleLED
 202 0036 EFE7     		b	.L22
 203              	.L28:
 175:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
 204              		.loc 1 175 0
 205 0038 0146     		mov	r1, r0
 206 003a 2868     		ldr	r0, [r5, #0]
 207 003c FFF7FEFF 		bl	vParTestSetLED
 180:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
 208              		.loc 1 180 0
 209 0040 FFF7FEFF 		bl	xTaskGetTickCount
 210 0044 0330     		adds	r0, r0, #3
 211              	.LVL18:
 183:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xTimeToWait %= comTX_MAX_BLOCK_TIME;
 212              		.loc 1 183 0
 213 0046 A6FB0024 		umull	r2, r4, r6, r0
 214              	.LVL19:
 215 004a 2109     		lsrs	r1, r4, #4
 216 004c 07FB1100 		mls	r0, r7, r1, r0
 217              	.LVL20:
 191:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		vTaskDelay( xTimeToWait );
 218              		.loc 1 191 0
 219 0050 3128     		cmp	r0, #49
 220 0052 98BF     		it	ls
 221 0054 3220     		movls	r0, #50
 222 0056 FFF7FEFF 		bl	vTaskDelay
 223              	.LVL21:
 166:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 224              		.loc 1 166 0
 225 005a 4124     		movs	r4, #65
 192:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	}
 226              		.loc 1 192 0
 227 005c DEE7     		b	.L27
 228              		.cfi_endproc
 229              	.LFE1:
 231 005e 00BF     		.section	.text.vAltStartComTestTasks,"ax",%progbits
 232              		.align	2
 233              		.global	vAltStartComTestTasks
 234              		.thumb
 235              		.thumb_func
 237              	vAltStartComTestTasks:
 238              	.LFB0:
 143:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
 239              		.loc 1 143 0
 240              		.cfi_startproc
 241              		@ args = 0, pretend = 0, frame = 0
 242              		@ frame_needed = 0, uses_anonymous_args = 0
 243              	.LVL22:
 244 0000 70B5     		push	{r4, r5, r6, lr}
 245              	.LCFI3:
 246              		.cfi_def_cfa_offset 16
 247              		.cfi_offset 14, -4
 248              		.cfi_offset 6, -8
 249              		.cfi_offset 5, -12
 250              		.cfi_offset 4, -16
 145:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	uxBaseLED = uxLED;
 251              		.loc 1 145 0
 252 0002 40F20003 		movw	r3, #:lower16:.LANCHOR0
 253 0006 C0F20003 		movt	r3, #:upper16:.LANCHOR0
 143:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
 254              		.loc 1 143 0
 255 000a 84B0     		sub	sp, sp, #16
 256              	.LCFI4:
 257              		.cfi_def_cfa_offset 32
 143:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
 258              		.loc 1 143 0
 259 000c 0546     		mov	r5, r0
 145:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	uxBaseLED = uxLED;
 260              		.loc 1 145 0
 261 000e 1A60     		str	r2, [r3, #0]
 146:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
 262              		.loc 1 146 0
 263 0010 0846     		mov	r0, r1
 264              	.LVL23:
 265 0012 1821     		movs	r1, #24
 266              	.LVL24:
 267 0014 FFF7FEFF 		bl	xSerialPortInitMinimal
 268              	.LVL25:
 149:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	xTaskCreate( vComTxTask, ( signed char * ) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHa
 269              		.loc 1 149 0
 270 0018 0024     		movs	r4, #0
 271 001a 40F20000 		movw	r0, #:lower16:vComTxTask
 272 001e 40F20001 		movw	r1, #:lower16:.LC0
 273 0022 7822     		movs	r2, #120
 274 0024 2346     		mov	r3, r4
 275 0026 C0F20001 		movt	r1, #:upper16:.LC0
 276 002a 6E1E     		subs	r6, r5, #1
 277 002c C0F20000 		movt	r0, #:upper16:vComTxTask
 278 0030 0096     		str	r6, [sp, #0]
 279 0032 0194     		str	r4, [sp, #4]
 280 0034 0294     		str	r4, [sp, #8]
 281 0036 0394     		str	r4, [sp, #12]
 282 0038 FFF7FEFF 		bl	xTaskGenericCreate
 150:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle
 283              		.loc 1 150 0
 284 003c 40F20000 		movw	r0, #:lower16:vComRxTask
 285 0040 40F20001 		movw	r1, #:lower16:.LC1
 286 0044 C0F20001 		movt	r1, #:upper16:.LC1
 287 0048 7822     		movs	r2, #120
 288 004a 2346     		mov	r3, r4
 289 004c C0F20000 		movt	r0, #:upper16:vComRxTask
 290 0050 0095     		str	r5, [sp, #0]
 291 0052 0194     		str	r4, [sp, #4]
 292 0054 0294     		str	r4, [sp, #8]
 293 0056 0394     		str	r4, [sp, #12]
 294 0058 FFF7FEFF 		bl	xTaskGenericCreate
 151:../FreeRTOS/Demo/Common/Minimal/comtest.c **** }
 295              		.loc 1 151 0
 296 005c 04B0     		add	sp, sp, #16
 297 005e 70BD     		pop	{r4, r5, r6, pc}
 298              		.cfi_endproc
 299              	.LFE0:
 301              		.section	.text.xAreComTestTasksStillRunning,"ax",%progbits
 302              		.align	2
 303              		.global	xAreComTestTasksStillRunning
 304              		.thumb
 305              		.thumb_func
 307              	xAreComTestTasksStillRunning:
 308              	.LFB3:
 263:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 			}
 264:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		}
 265:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	}
 266:../FreeRTOS/Demo/Common/Minimal/comtest.c **** } /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
 267:../FreeRTOS/Demo/Common/Minimal/comtest.c **** /*-----------------------------------------------------------*/
 268:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 269:../FreeRTOS/Demo/Common/Minimal/comtest.c **** portBASE_TYPE xAreComTestTasksStillRunning( void )
 270:../FreeRTOS/Demo/Common/Minimal/comtest.c **** {
 309              		.loc 1 270 0
 310              		.cfi_startproc
 311              		@ args = 0, pretend = 0, frame = 0
 312              		@ frame_needed = 0, uses_anonymous_args = 0
 313              		@ link register save eliminated.
 271:../FreeRTOS/Demo/Common/Minimal/comtest.c **** portBASE_TYPE xReturn;
 272:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 273:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	/* If the count of successful reception loops has not changed than at
 274:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	some time an error occurred (i.e. a character was received out of sequence)
 275:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	and we will return false. */
 276:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
 314              		.loc 1 276 0
 315 0000 40F20003 		movw	r3, #:lower16:.LANCHOR1
 316 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR1
 317 0008 1868     		ldr	r0, [r3, #0]
 318              	.LVL26:
 277:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	{
 278:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xReturn = pdFALSE;
 279:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	}
 280:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	else
 281:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	{
 282:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 		xReturn = pdTRUE;
 283:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	}
 284:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 285:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	/* Reset the count of successful Rx loops.  When this function is called
 286:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	again we expect this to have been incremented. */
 287:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
 319              		.loc 1 287 0
 320 000a 0022     		movs	r2, #0
 288:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 
 289:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	return xReturn;
 290:../FreeRTOS/Demo/Common/Minimal/comtest.c **** }
 321              		.loc 1 290 0
 322 000c 801A     		subs	r0, r0, r2
 287:../FreeRTOS/Demo/Common/Minimal/comtest.c **** 	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
 323              		.loc 1 287 0
 324 000e 1A60     		str	r2, [r3, #0]
 325              		.loc 1 290 0
 326 0010 18BF     		it	ne
 327 0012 0120     		movne	r0, #1
 328              	.LVL27:
 329 0014 7047     		bx	lr
 330              		.cfi_endproc
 331              	.LFE3:
 333 0016 00BF     		.section	.bss.uxRxLoops,"aw",%nobits
 334              		.align	2
 335              		.set	.LANCHOR1,. + 0
 338              	uxRxLoops:
 339 0000 00000000 		.space	4
 340              		.section	.rodata.str1.4,"aMS",%progbits,1
 341              		.align	2
 342              	.LC0:
 343 0000 434F4D54 		.ascii	"COMTx\000"
 343      7800
 344 0006 0000     		.space	2
 345              	.LC1:
 346 0008 434F4D52 		.ascii	"COMRx\000"
 346      7800
 347 000e 0000     		.section	.bss.uxBaseLED,"aw",%nobits
 348              		.align	2
 349              		.set	.LANCHOR0,. + 0
 352              	uxBaseLED:
 353 0000 00000000 		.space	4
 354              		.text
 355              	.Letext0:
 356              		.file 2 "../FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM3/portmacro.h"
 357              		.file 3 "../FreeRTOS/Source/include/task.h"
 358              		.file 4 "../FreeRTOS/Demo/Common/include/serial.h"
DEFINED SYMBOLS
                            *ABS*:00000000 comtest.c
     /tmp/ccsfGdmk.s:19     .text.vComRxTask:00000000 $t
     /tmp/ccsfGdmk.s:23     .text.vComRxTask:00000000 vComRxTask
     /tmp/ccsfGdmk.s:349    .bss.uxBaseLED:00000000 .LANCHOR0
     /tmp/ccsfGdmk.s:335    .bss.uxRxLoops:00000000 .LANCHOR1
     /tmp/ccsfGdmk.s:146    .text.vComTxTask:00000000 $t
     /tmp/ccsfGdmk.s:150    .text.vComTxTask:00000000 vComTxTask
     /tmp/ccsfGdmk.s:232    .text.vAltStartComTestTasks:00000000 $t
     /tmp/ccsfGdmk.s:237    .text.vAltStartComTestTasks:00000000 vAltStartComTestTasks
     /tmp/ccsfGdmk.s:342    .rodata.str1.4:00000000 .LC0
     /tmp/ccsfGdmk.s:345    .rodata.str1.4:00000008 .LC1
     /tmp/ccsfGdmk.s:302    .text.xAreComTestTasksStillRunning:00000000 $t
     /tmp/ccsfGdmk.s:307    .text.xAreComTestTasksStillRunning:00000000 xAreComTestTasksStillRunning
     /tmp/ccsfGdmk.s:334    .bss.uxRxLoops:00000000 $d
     /tmp/ccsfGdmk.s:338    .bss.uxRxLoops:00000000 uxRxLoops
     /tmp/ccsfGdmk.s:341    .rodata.str1.4:00000000 $d
     /tmp/ccsfGdmk.s:348    .bss.uxBaseLED:00000000 $d
     /tmp/ccsfGdmk.s:352    .bss.uxBaseLED:00000000 uxBaseLED
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xSerialGetChar
vParTestToggleLED
vParTestSetLED
xSerialPutChar
xTaskGetTickCount
vTaskDelay
xSerialPortInitMinimal
xTaskGenericCreate
