   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"AltBlock.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.vSecondaryBlockTimeTestTask,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	vSecondaryBlockTimeTestTask:
  24              	.LFB2:
  25              		.file 1 "../FreeRTOS/Demo/Common/Minimal/AltBlock.c"
   1:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /*
   2:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	
   4:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
   5:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     ***************************************************************************
   6:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *                                                                       *
   7:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    available.                                                         *
  10:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *                                                                       *
  11:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *                                                                       *
  18:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *                                                                       *
  20:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****      *                                                                       *
  22:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     ***************************************************************************
  23:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  24:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  25:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  27:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  42:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  44:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     contact details.
  46:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  47:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     critical systems.
  49:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  50:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     licensing and training services.
  52:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** */
  53:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  54:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /*
  55:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****  * This is a version of BlockTim.c that uses the light weight API.
  56:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****  *
  57:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****  * This file contains some test scenarios that ensure tasks do not exit queue
  58:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****  * send or receive functions prematurely.  A description of the tests is
  59:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****  * included within the code.
  60:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****  */
  61:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  62:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* Kernel includes. */
  63:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #include "FreeRTOS.h"
  64:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #include "task.h"
  65:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #include "queue.h"
  66:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  67:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* Demo includes. */
  68:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #include "AltBlock.h"
  69:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  70:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* Task priorities. */
  71:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktPRIMARY_PRIORITY			( 3 )
  72:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktSECONDARY_PRIORITY		( 2 )
  73:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  74:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* Task behaviour. */
  75:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktQUEUE_LENGTH				( 5 )
  76:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktSHORT_WAIT				( ( ( portTickType ) 20 ) / portTICK_RATE_MS )
  77:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktPRIMARY_BLOCK_TIME		( 10 )
  78:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktALLOWABLE_MARGIN			( 12 )
  79:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktTIME_TO_BLOCK			( 175 )
  80:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktDONT_BLOCK				( ( portTickType ) 0 )
  81:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** #define bktRUN_INDICATOR			( ( unsigned portBASE_TYPE ) 0x55 )
  82:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  83:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* The queue on which the tasks block. */
  84:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static xQueueHandle xTestQueue;
  85:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  86:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* Handle to the secondary task is required by the primary task for calls
  87:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** to vTaskSuspend/Resume(). */
  88:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static xTaskHandle xSecondary;
  89:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  90:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* Used to ensure that tasks are still executing without error. */
  91:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static portBASE_TYPE xPrimaryCycles = 0, xSecondaryCycles = 0;
  92:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static portBASE_TYPE xErrorOccurred = pdFALSE;
  93:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  94:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* Provides a simple mechanism for the primary task to know when the
  95:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** secondary task has executed. */
  96:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static volatile unsigned portBASE_TYPE xRunIndicator;
  97:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
  98:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /* The two test tasks.  Their behaviour is commented within the files. */
  99:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters );
 100:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters );
 101:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 102:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /*-----------------------------------------------------------*/
 103:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 104:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** void vCreateAltBlockTimeTasks( void )
 105:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
 106:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	/* Create the queue on which the two tasks block. */
 107:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
 108:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 109:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 110:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	in use.  The queue registry is provided as a means for kernel aware 
 111:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 112:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 113:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
 114:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	defined to be less than 1. */
 115:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	vQueueAddToRegistry( xTestQueue, ( signed portCHAR * ) "AltBlockQueue" );
 116:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 117:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 118:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	/* Create the two test tasks. */
 119:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed portCHAR * )"FBTest1", configMINIMAL_STACK_SIZE, 
 120:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed portCHAR * )"FBTest2", configMINIMAL_STACK_SIZE
 121:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** }
 122:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /*-----------------------------------------------------------*/
 123:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 124:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters )
 125:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
 126:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portBASE_TYPE xItem, xData;
 127:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portTickType xTimeWhenBlocking;
 128:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portTickType xTimeToBlock, xBlockedTime;
 129:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 130:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	#ifdef USE_STDIO
 131:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	void vPrintDisplayMessage( const portCHAR * const * ppcMessageToSend );
 132:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	
 133:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		const portCHAR * const pcTaskStartMsg = "Alt primary block time test started.\r\n";
 134:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 135:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* Queue a message for printing to say the task has started. */
 136:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vPrintDisplayMessage( &pcTaskStartMsg );
 137:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	#endif
 138:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 139:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	( void ) pvParameters;
 140:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 141:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	for( ;; )
 142:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	{
 143:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/*********************************************************************
 144:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Test 1
 145:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 146:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Simple block time wakeup test on queue receives. */
 147:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 148:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 149:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* The queue is empty. Attempt to read from the queue using a block
 150:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 151:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 152:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 153:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* A critical section is used to minimise the jitter in the time
 154:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			measurements. */
 155:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portENTER_CRITICAL();
 156:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 157:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xTimeWhenBlocking = xTaskGetTickCount();
 158:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				
 159:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* We should unblock after xTimeToBlock having not received
 160:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				anything on the queue. */
 161:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				if( xQueueAltReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 162:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				{
 163:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 164:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				}
 165:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 166:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* How long were we blocked for? */
 167:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 168:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 169:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portEXIT_CRITICAL();
 170:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 171:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime < xTimeToBlock )
 172:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 173:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* Should not have blocked for less than we requested. */
 174:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 175:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 176:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 177:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 178:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 179:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* Should not have blocked for longer than we requested,
 180:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				although we would not necessarily run as soon as we were
 181:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				unblocked so a margin is allowed. */
 182:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 183:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 184:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 185:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 186:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 187:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		#if configUSE_PREEMPTION == 0
 188:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			taskYIELD();
 189:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		#endif
 190:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 191:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 192:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/*********************************************************************
 193:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Test 2
 194:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 195:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Simple block time wakeup test on queue sends.
 196:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 197:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		First fill the queue.  It should be empty so all sends should pass. */
 198:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 199:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 200:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 201:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 202:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 203:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 204:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 205:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 206:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 207:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 208:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* The queue is full. Attempt to write to the queue using a block
 209:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 210:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 211:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 212:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portENTER_CRITICAL();
 213:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 214:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xTimeWhenBlocking = xTaskGetTickCount();
 215:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				
 216:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* We should unblock after xTimeToBlock having not received
 217:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				anything on the queue. */
 218:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				if( xQueueAltSendToBack( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 219:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				{
 220:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 221:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				}
 222:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 223:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* How long were we blocked for? */
 224:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 225:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 226:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portEXIT_CRITICAL();
 227:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 228:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime < xTimeToBlock )
 229:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 230:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* Should not have blocked for less than we requested. */
 231:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 232:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 233:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 234:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 235:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 236:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* Should not have blocked for longer than we requested,
 237:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				although we would not necessarily run as soon as we were
 238:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				unblocked so a margin is allowed. */
 239:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 240:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 241:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 242:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 243:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		#if configUSE_PREEMPTION == 0
 244:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			taskYIELD();
 245:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		#endif
 246:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 247:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		
 248:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/*********************************************************************
 249:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Test 3
 250:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 251:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		Wake the other task, it will block attempting to post to the queue.
 252:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		When we read from the queue the other task will wake, but before it
 253:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		can run we will post to the queue again.  When the other task runs it
 254:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		will find the queue still full, even though it was woken.  It should
 255:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		recognise that its block time has not expired and return to block for
 256:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		the remains of its block time.
 257:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 258:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		Wake the other task so it blocks attempting to post to the already
 259:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		full queue. */
 260:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 261:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskResume( xSecondary );
 262:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 263:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* We need to wait a little to ensure the other task executes. */
 264:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 265:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 266:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* The other task has not yet executed. */
 267:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 268:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 269:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* Make sure the other task is blocked on the queue. */
 270:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 271:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 272:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 273:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 274:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 275:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* Now when we make space on the queue the other task should wake
 276:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			but not execute as this task has higher priority. */				
 277:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 278:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 279:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 280:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 281:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 282:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* Now fill the queue again before the other task gets a chance to
 283:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			execute.  If the other task had executed we would find the queue
 284:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			full ourselves, and the other task have set xRunIndicator. */
 285:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 286:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 287:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 288:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 289:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 290:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 291:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 292:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* The other task should not have executed. */
 293:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 294:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 295:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 296:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* Raise the priority of the other task so it executes and blocks
 297:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			on the queue again. */
 298:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 299:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 300:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* The other task should now have re-blocked without exiting the
 301:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			queue function. */
 302:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 303:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 304:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* The other task should not have executed outside of the
 305:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				queue function. */
 306:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 307:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 308:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 309:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* Set the priority back down. */
 310:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );			
 311:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 312:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 313:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 314:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		unblocked at the correct time, then suspend itself. */
 315:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 316:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 317:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 318:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 319:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 320:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 321:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 322:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		#if configUSE_PREEMPTION == 0
 323:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			taskYIELD();
 324:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		#endif
 325:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 326:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/*********************************************************************
 327:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Test 4
 328:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 329:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		As per test 3 - but with the send and receive the other way around.
 330:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		The other task blocks attempting to read from the queue.
 331:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 332:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		Empty the queue.  We should find that it is full. */
 333:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 334:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 335:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 336:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 337:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 338:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 339:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 340:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		
 341:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* Wake the other task so it blocks attempting to read from  the
 342:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		already	empty queue. */
 343:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskResume( xSecondary );
 344:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 345:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* We need to wait a little to ensure the other task executes. */
 346:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 347:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 348:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 349:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 350:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 351:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 352:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 353:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 354:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 355:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* Now when we place an item on the queue the other task should
 356:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			wake but not execute as this task has higher priority. */				
 357:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 358:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 359:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 360:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 361:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 362:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* Now empty the queue again before the other task gets a chance to
 363:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			execute.  If the other task had executed we would find the queue
 364:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			empty ourselves, and the other task would be suspended. */
 365:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 366:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 367:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 368:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 369:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 370:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 371:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 372:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* The other task should not have executed. */
 373:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 374:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 375:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 376:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* Raise the priority of the other task so it executes and blocks
 377:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			on the queue again. */
 378:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 379:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 380:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* The other task should now have re-blocked without exiting the
 381:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			queue function. */
 382:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 383:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 384:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				/* The other task should not have executed outside of the
 385:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				queue function. */
 386:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 387:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 388:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );			
 389:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 390:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 391:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 392:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		unblocked at the correct time, then suspend itself. */
 393:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 394:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 395:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 396:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 397:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 398:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 399:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xPrimaryCycles++;
 400:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	}
 401:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** }
 402:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /*-----------------------------------------------------------*/
 403:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 404:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters )
 405:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
  26              		.loc 1 405 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 36
  34              		.cfi_offset 14, -4
  35              		.cfi_offset 11, -8
  36              		.cfi_offset 10, -12
  37              		.cfi_offset 9, -16
  38              		.cfi_offset 8, -20
  39              		.cfi_offset 7, -24
  40              		.cfi_offset 6, -28
  41              		.cfi_offset 5, -32
  42              		.cfi_offset 4, -36
  43 0004 40F20004 		movw	r4, #:lower16:.LANCHOR0
  44 0008 40F2000A 		movw	sl, #:lower16:.LANCHOR1
  45 000c 40F20006 		movw	r6, #:lower16:.LANCHOR2
  46 0010 40F20008 		movw	r8, #:lower16:.LANCHOR3
  47 0014 83B0     		sub	sp, sp, #12
  48              	.LCFI1:
  49              		.cfi_def_cfa_offset 48
  50 0016 C0F20004 		movt	r4, #:upper16:.LANCHOR0
  51 001a C0F2000A 		movt	sl, #:upper16:.LANCHOR1
  52 001e C0F20006 		movt	r6, #:upper16:.LANCHOR2
  53 0022 C0F20008 		movt	r8, #:upper16:.LANCHOR3
 406:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portTickType xTimeWhenBlocking, xBlockedTime;
 407:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portBASE_TYPE xData;
 408:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 409:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	#ifdef USE_STDIO
 410:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	void vPrintDisplayMessage( const portCHAR * const * ppcMessageToSend );
 411:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	
 412:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		const portCHAR * const pcTaskStartMsg = "Alt secondary block time test started.\r\n";
 413:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 414:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* Queue a message for printing to say the task has started. */
 415:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vPrintDisplayMessage( &pcTaskStartMsg );
 416:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	#endif
 417:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 418:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	( void ) pvParameters;
 419:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 420:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	for( ;; )
 421:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	{
 422:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/*********************************************************************
 423:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Test 1 and 2
 424:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 425:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		This task does does not participate in these tests. */
 426:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskSuspend( NULL );
  54              		.loc 1 426 0
  55 0026 4FF0000B 		mov	fp, #0
 427:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 428:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/*********************************************************************
 429:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Test 3
 430:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 431:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		The first thing we do is attempt to read from the queue.  It should be
 432:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		full so we block.  Note the time before we block so we can check the
 433:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		wake time is as per that expected. */
 434:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		portENTER_CRITICAL();
 435:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 436:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 437:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			
 438:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* We should unblock after bktTIME_TO_BLOCK having not received
 439:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			anything on the queue. */
 440:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xData = 0;
 441:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xRunIndicator = bktRUN_INDICATOR;
  56              		.loc 1 441 0
  57 002a 5525     		movs	r5, #85
 442:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
 443:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 444:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
  58              		.loc 1 444 0
  59 002c 4FF00109 		mov	r9, #1
  60              	.LVL1:
  61              	.L8:
 426:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskSuspend( NULL );
  62              		.loc 1 426 0
  63 0030 0020     		movs	r0, #0
  64 0032 FFF7FEFF 		bl	vTaskSuspend
 434:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		portENTER_CRITICAL();
  65              		.loc 1 434 0
  66 0036 FFF7FEFF 		bl	vPortEnterCritical
 436:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
  67              		.loc 1 436 0
  68 003a FFF7FEFF 		bl	xTaskGetTickCount
 442:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
  69              		.loc 1 442 0
  70 003e 01A9     		add	r1, sp, #4
 436:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
  71              		.loc 1 436 0
  72 0040 0746     		mov	r7, r0
  73              	.LVL2:
 442:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
  74              		.loc 1 442 0
  75 0042 AF22     		movs	r2, #175
  76 0044 DAF80000 		ldr	r0, [sl, #0]
  77              	.LVL3:
  78 0048 0023     		movs	r3, #0
 440:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xData = 0;
  79              		.loc 1 440 0
  80 004a CDF804B0 		str	fp, [sp, #4]
 441:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xRunIndicator = bktRUN_INDICATOR;
  81              		.loc 1 441 0
  82 004e 2560     		str	r5, [r4, #0]
 442:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
  83              		.loc 1 442 0
  84 0050 FFF7FEFF 		bl	xQueueAltGenericSend
  85 0054 08B1     		cbz	r0, .L2
  86              		.loc 1 444 0
  87 0056 C6F80090 		str	r9, [r6, #0]
  88              	.L2:
 445:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 446:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 447:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* How long were we inside the send function? */
 448:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
  89              		.loc 1 448 0
  90 005a FFF7FEFF 		bl	xTaskGetTickCount
  91 005e C71B     		subs	r7, r0, r7
  92              	.LVL4:
 449:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 450:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		portEXIT_CRITICAL();
  93              		.loc 1 450 0
  94 0060 FFF7FEFF 		bl	vPortExitCritical
 451:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 452:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 453:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
  95              		.loc 1 453 0
  96 0064 AE2F     		cmp	r7, #174
  97 0066 01D9     		bls	.L9
 454:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 455:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xErrorOccurred = pdTRUE;
 456:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 457:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 458:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 459:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		either.  A margin is permitted as we would not necessarily run as
 460:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		soon as we unblocked. */
 461:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
  98              		.loc 1 461 0
  99 0068 BB2F     		cmp	r7, #187
 100 006a 01D9     		bls	.L4
 101              	.L9:
 462:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 463:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xErrorOccurred = pdTRUE;
 102              		.loc 1 463 0
 103 006c C6F80090 		str	r9, [r6, #0]
 104              	.L4:
 464:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 465:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 466:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* Suspend ready for test 3. */
 467:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = bktRUN_INDICATOR;
 468:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskSuspend( NULL );
 105              		.loc 1 468 0
 106 0070 0020     		movs	r0, #0
 467:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = bktRUN_INDICATOR;
 107              		.loc 1 467 0
 108 0072 2560     		str	r5, [r4, #0]
 109              		.loc 1 468 0
 110 0074 FFF7FEFF 		bl	vTaskSuspend
 469:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 470:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/*********************************************************************
 471:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****         Test 4
 472:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 473:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		As per test three, but with the send and receive reversed. */
 474:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		portENTER_CRITICAL();
 111              		.loc 1 474 0
 112 0078 FFF7FEFF 		bl	vPortEnterCritical
 475:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 476:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 113              		.loc 1 476 0
 114 007c FFF7FEFF 		bl	xTaskGetTickCount
 477:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			
 478:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			/* We should unblock after bktTIME_TO_BLOCK having not received
 479:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			anything on the queue. */
 480:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xRunIndicator = bktRUN_INDICATOR;
 481:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
 115              		.loc 1 481 0
 116 0080 01A9     		add	r1, sp, #4
 476:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 117              		.loc 1 476 0
 118 0082 0746     		mov	r7, r0
 119              	.LVL5:
 120              		.loc 1 481 0
 121 0084 AF22     		movs	r2, #175
 122 0086 DAF80000 		ldr	r0, [sl, #0]
 123              	.LVL6:
 124 008a 0023     		movs	r3, #0
 480:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xRunIndicator = bktRUN_INDICATOR;
 125              		.loc 1 480 0
 126 008c 2560     		str	r5, [r4, #0]
 127              		.loc 1 481 0
 128 008e FFF7FEFF 		bl	xQueueAltGenericReceive
 129 0092 08B1     		cbz	r0, .L5
 482:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			{
 483:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 130              		.loc 1 483 0
 131 0094 C6F80090 		str	r9, [r6, #0]
 132              	.L5:
 484:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			}
 485:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 486:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 133              		.loc 1 486 0
 134 0098 FFF7FEFF 		bl	xTaskGetTickCount
 135 009c C71B     		subs	r7, r0, r7
 136              	.LVL7:
 487:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 488:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		portEXIT_CRITICAL();
 137              		.loc 1 488 0
 138 009e FFF7FEFF 		bl	vPortExitCritical
 489:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 490:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 491:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
 139              		.loc 1 491 0
 140 00a2 AE2F     		cmp	r7, #174
 141 00a4 01D9     		bls	.L10
 492:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 493:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xErrorOccurred = pdTRUE;
 494:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 495:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 496:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 497:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		either.  A margin is permitted as we would not necessarily run as soon
 498:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		as we unblocked. */
 499:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 142              		.loc 1 499 0
 143 00a6 BB2F     		cmp	r7, #187
 144 00a8 01D9     		bls	.L7
 145              	.L10:
 500:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		{
 501:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xErrorOccurred = pdTRUE;
 146              		.loc 1 501 0
 147 00aa C6F80090 		str	r9, [r6, #0]
 148              	.L7:
 502:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		}
 503:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 504:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = bktRUN_INDICATOR;
 505:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 506:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xSecondaryCycles++;
 149              		.loc 1 506 0
 150 00ae D8F80000 		ldr	r0, [r8, #0]
 504:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = bktRUN_INDICATOR;
 151              		.loc 1 504 0
 152 00b2 2560     		str	r5, [r4, #0]
 153              		.loc 1 506 0
 154 00b4 431C     		adds	r3, r0, #1
 155 00b6 C8F80030 		str	r3, [r8, #0]
 507:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	}
 156              		.loc 1 507 0
 157 00ba B9E7     		b	.L8
 158              		.cfi_endproc
 159              	.LFE2:
 161              		.section	.text.vPrimaryBlockTimeTestTask,"ax",%progbits
 162              		.align	2
 163              		.thumb
 164              		.thumb_func
 166              	vPrimaryBlockTimeTestTask:
 167              	.LFB1:
 125:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
 168              		.loc 1 125 0
 169              		.cfi_startproc
 170              		@ args = 0, pretend = 0, frame = 16
 171              		@ frame_needed = 0, uses_anonymous_args = 0
 172              	.LVL8:
 173 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 174              	.LCFI2:
 175              		.cfi_def_cfa_offset 36
 176              		.cfi_offset 14, -4
 177              		.cfi_offset 11, -8
 178              		.cfi_offset 10, -12
 179              		.cfi_offset 9, -16
 180              		.cfi_offset 8, -20
 181              		.cfi_offset 7, -24
 182              		.cfi_offset 6, -28
 183              		.cfi_offset 5, -32
 184              		.cfi_offset 4, -36
 185 0004 40F20002 		movw	r2, #:lower16:.LANCHOR5
 186 0008 85B0     		sub	sp, sp, #20
 187              	.LCFI3:
 188              		.cfi_def_cfa_offset 56
 189 000a 40F20004 		movw	r4, #:lower16:.LANCHOR0
 190 000e 40F20006 		movw	r6, #:lower16:.LANCHOR1
 191 0012 40F20005 		movw	r5, #:lower16:.LANCHOR2
 192 0016 40F20009 		movw	r9, #:lower16:.LANCHOR4
 193 001a C0F20002 		movt	r2, #:upper16:.LANCHOR5
 194 001e C0F20004 		movt	r4, #:upper16:.LANCHOR0
 195 0022 C0F20006 		movt	r6, #:upper16:.LANCHOR1
 196 0026 C0F20005 		movt	r5, #:upper16:.LANCHOR2
 197 002a C0F20009 		movt	r9, #:upper16:.LANCHOR4
 198 002e 0192     		str	r2, [sp, #4]
 199              	.LVL9:
 200              	.L46:
 147:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 201              		.loc 1 147 0
 202 0030 0023     		movs	r3, #0
 163:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 203              		.loc 1 163 0
 204 0032 3746     		mov	r7, r6
 147:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 205              		.loc 1 147 0
 206 0034 0293     		str	r3, [sp, #8]
 151:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 207              		.loc 1 151 0
 208 0036 4FF00A0B 		mov	fp, #10
 163:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 209              		.loc 1 163 0
 210 003a 4FF0010A 		mov	sl, #1
 211 003e A046     		mov	r8, r4
 212 0040 2E46     		mov	r6, r5
 213              	.L16:
 151:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 214              		.loc 1 151 0
 215 0042 0BFA03F4 		lsl	r4, fp, r3
 216              	.LVL10:
 155:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portENTER_CRITICAL();
 217              		.loc 1 155 0
 218 0046 FFF7FEFF 		bl	vPortEnterCritical
 157:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xTimeWhenBlocking = xTaskGetTickCount();
 219              		.loc 1 157 0
 220 004a FFF7FEFF 		bl	xTaskGetTickCount
 161:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				if( xQueueAltReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 221              		.loc 1 161 0
 222 004e 03A9     		add	r1, sp, #12
 157:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xTimeWhenBlocking = xTaskGetTickCount();
 223              		.loc 1 157 0
 224 0050 0546     		mov	r5, r0
 225              	.LVL11:
 161:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				if( xQueueAltReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 226              		.loc 1 161 0
 227 0052 2246     		mov	r2, r4
 228 0054 0023     		movs	r3, #0
 229 0056 3868     		ldr	r0, [r7, #0]
 230              	.LVL12:
 231 0058 FFF7FEFF 		bl	xQueueAltGenericReceive
 232 005c 08B1     		cbz	r0, .L13
 163:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 233              		.loc 1 163 0
 234 005e C6F800A0 		str	sl, [r6, #0]
 235              	.L13:
 167:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 236              		.loc 1 167 0
 237 0062 FFF7FEFF 		bl	xTaskGetTickCount
 238 0066 451B     		subs	r5, r0, r5
 239              	.LVL13:
 169:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portEXIT_CRITICAL();
 240              		.loc 1 169 0
 241 0068 FFF7FEFF 		bl	vPortExitCritical
 147:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 242              		.loc 1 147 0
 243 006c 029B     		ldr	r3, [sp, #8]
 177:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 244              		.loc 1 177 0
 245 006e 04F10C00 		add	r0, r4, #12
 147:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 246              		.loc 1 147 0
 247 0072 0133     		adds	r3, r3, #1
 171:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime < xTimeToBlock )
 248              		.loc 1 171 0
 249 0074 AC42     		cmp	r4, r5
 174:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 250              		.loc 1 174 0
 251 0076 88BF     		it	hi
 252 0078 C6F800A0 		strhi	sl, [r6, #0]
 177:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 253              		.loc 1 177 0
 254 007c 8542     		cmp	r5, r0
 182:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 255              		.loc 1 182 0
 256 007e 88BF     		it	hi
 257 0080 C6F800A0 		strhi	sl, [r6, #0]
 147:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 258              		.loc 1 147 0
 259 0084 042B     		cmp	r3, #4
 260 0086 0293     		str	r3, [sp, #8]
 261 0088 DBDD     		ble	.L16
 198:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 262              		.loc 1 198 0
 263 008a 0021     		movs	r1, #0
 264 008c 3546     		mov	r5, r6
 265              	.LVL14:
 266 008e 4446     		mov	r4, r8
 267              	.LVL15:
 268 0090 3E46     		mov	r6, r7
 269 0092 0291     		str	r1, [sp, #8]
 202:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 270              		.loc 1 202 0
 271 0094 0127     		movs	r7, #1
 272              	.LVL16:
 273              	.L18:
 200:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 274              		.loc 1 200 0
 275 0096 0022     		movs	r2, #0
 276 0098 1346     		mov	r3, r2
 277 009a 3068     		ldr	r0, [r6, #0]
 278 009c 02A9     		add	r1, sp, #8
 279 009e FFF7FEFF 		bl	xQueueAltGenericSend
 280 00a2 0128     		cmp	r0, #1
 198:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 281              		.loc 1 198 0
 282 00a4 0298     		ldr	r0, [sp, #8]
 202:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 283              		.loc 1 202 0
 284 00a6 18BF     		it	ne
 285 00a8 2F60     		strne	r7, [r5, #0]
 198:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 286              		.loc 1 198 0
 287 00aa 00F10102 		add	r2, r0, #1
 288 00ae 042A     		cmp	r2, #4
 289 00b0 0292     		str	r2, [sp, #8]
 290 00b2 F0DD     		ble	.L18
 206:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 291              		.loc 1 206 0
 292 00b4 0023     		movs	r3, #0
 220:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 293              		.loc 1 220 0
 294 00b6 3746     		mov	r7, r6
 206:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 295              		.loc 1 206 0
 296 00b8 0293     		str	r3, [sp, #8]
 210:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 297              		.loc 1 210 0
 298 00ba 4FF00A0B 		mov	fp, #10
 220:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 299              		.loc 1 220 0
 300 00be 4FF0010A 		mov	sl, #1
 301 00c2 A046     		mov	r8, r4
 302 00c4 2E46     		mov	r6, r5
 303              	.L22:
 210:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 304              		.loc 1 210 0
 305 00c6 0BFA03F4 		lsl	r4, fp, r3
 306              	.LVL17:
 212:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portENTER_CRITICAL();
 307              		.loc 1 212 0
 308 00ca FFF7FEFF 		bl	vPortEnterCritical
 214:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xTimeWhenBlocking = xTaskGetTickCount();
 309              		.loc 1 214 0
 310 00ce FFF7FEFF 		bl	xTaskGetTickCount
 218:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				if( xQueueAltSendToBack( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 311              		.loc 1 218 0
 312 00d2 02A9     		add	r1, sp, #8
 214:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xTimeWhenBlocking = xTaskGetTickCount();
 313              		.loc 1 214 0
 314 00d4 0546     		mov	r5, r0
 315              	.LVL18:
 218:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				if( xQueueAltSendToBack( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 316              		.loc 1 218 0
 317 00d6 2246     		mov	r2, r4
 318 00d8 0023     		movs	r3, #0
 319 00da 3868     		ldr	r0, [r7, #0]
 320              	.LVL19:
 321 00dc FFF7FEFF 		bl	xQueueAltGenericSend
 322 00e0 08B1     		cbz	r0, .L19
 220:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 					xErrorOccurred = pdTRUE;
 323              		.loc 1 220 0
 324 00e2 C6F800A0 		str	sl, [r6, #0]
 325              	.L19:
 224:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 326              		.loc 1 224 0
 327 00e6 FFF7FEFF 		bl	xTaskGetTickCount
 328 00ea 451B     		subs	r5, r0, r5
 329              	.LVL20:
 226:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			portEXIT_CRITICAL();
 330              		.loc 1 226 0
 331 00ec FFF7FEFF 		bl	vPortExitCritical
 206:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 332              		.loc 1 206 0
 333 00f0 029B     		ldr	r3, [sp, #8]
 234:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 334              		.loc 1 234 0
 335 00f2 04F10C01 		add	r1, r4, #12
 206:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 336              		.loc 1 206 0
 337 00f6 0133     		adds	r3, r3, #1
 228:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime < xTimeToBlock )
 338              		.loc 1 228 0
 339 00f8 AC42     		cmp	r4, r5
 231:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 340              		.loc 1 231 0
 341 00fa 88BF     		it	hi
 342 00fc C6F800A0 		strhi	sl, [r6, #0]
 234:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 343              		.loc 1 234 0
 344 0100 8D42     		cmp	r5, r1
 239:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 345              		.loc 1 239 0
 346 0102 88BF     		it	hi
 347 0104 C6F800A0 		strhi	sl, [r6, #0]
 206:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 348              		.loc 1 206 0
 349 0108 042B     		cmp	r3, #4
 350 010a 0293     		str	r3, [sp, #8]
 351 010c DBDD     		ble	.L22
 260:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 352              		.loc 1 260 0
 353 010e 0022     		movs	r2, #0
 261:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskResume( xSecondary );
 354              		.loc 1 261 0
 355 0110 D9F80000 		ldr	r0, [r9, #0]
 260:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 356              		.loc 1 260 0
 357 0114 C8F80020 		str	r2, [r8, #0]
 261:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskResume( xSecondary );
 358              		.loc 1 261 0
 359 0118 FFF7FEFF 		bl	vTaskResume
 360 011c 3546     		mov	r5, r6
 361              	.LVL21:
 362 011e 3E46     		mov	r6, r7
 264:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 363              		.loc 1 264 0
 364 0120 D8F80070 		ldr	r7, [r8, #0]
 365 0124 4446     		mov	r4, r8
 366              	.LVL22:
 367 0126 552F     		cmp	r7, #85
 368 0128 05D0     		beq	.L64
 369              	.L53:
 267:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 370              		.loc 1 267 0
 371 012a 1420     		movs	r0, #20
 372 012c FFF7FEFF 		bl	vTaskDelay
 264:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 373              		.loc 1 264 0
 374 0130 2068     		ldr	r0, [r4, #0]
 375 0132 5528     		cmp	r0, #85
 376 0134 F9D1     		bne	.L53
 377              	.L64:
 270:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 378              		.loc 1 270 0
 379 0136 1420     		movs	r0, #20
 271:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 380              		.loc 1 271 0
 381 0138 40F20008 		movw	r8, #:lower16:.LANCHOR0
 270:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 382              		.loc 1 270 0
 383 013c FFF7FEFF 		bl	vTaskDelay
 271:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 384              		.loc 1 271 0
 385 0140 C0F20008 		movt	r8, #:upper16:.LANCHOR0
 386 0144 0021     		movs	r1, #0
 387 0146 C8F80010 		str	r1, [r8, #0]
 273:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 388              		.loc 1 273 0
 389 014a 0291     		str	r1, [sp, #8]
 279:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 390              		.loc 1 279 0
 391 014c 0127     		movs	r7, #1
 392              	.L52:
 277:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 393              		.loc 1 277 0
 394 014e 0022     		movs	r2, #0
 395 0150 1346     		mov	r3, r2
 396 0152 03A9     		add	r1, sp, #12
 397 0154 3068     		ldr	r0, [r6, #0]
 398 0156 FFF7FEFF 		bl	xQueueAltGenericReceive
 285:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 399              		.loc 1 285 0
 400 015a 0022     		movs	r2, #0
 277:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 401              		.loc 1 277 0
 402 015c 0128     		cmp	r0, #1
 285:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 403              		.loc 1 285 0
 404 015e 1346     		mov	r3, r2
 279:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 405              		.loc 1 279 0
 406 0160 18BF     		it	ne
 407 0162 2F60     		strne	r7, [r5, #0]
 285:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 408              		.loc 1 285 0
 409 0164 02A9     		add	r1, sp, #8
 410 0166 3068     		ldr	r0, [r6, #0]
 411 0168 FFF7FEFF 		bl	xQueueAltGenericSend
 290:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 412              		.loc 1 290 0
 413 016c 2368     		ldr	r3, [r4, #0]
 298:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 414              		.loc 1 298 0
 415 016e 0521     		movs	r1, #5
 285:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 416              		.loc 1 285 0
 417 0170 0128     		cmp	r0, #1
 287:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 418              		.loc 1 287 0
 419 0172 18BF     		it	ne
 420 0174 2F60     		strne	r7, [r5, #0]
 290:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 421              		.loc 1 290 0
 422 0176 552B     		cmp	r3, #85
 293:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 423              		.loc 1 293 0
 424 0178 08BF     		it	eq
 425 017a 2F60     		streq	r7, [r5, #0]
 298:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 426              		.loc 1 298 0
 427 017c D9F80000 		ldr	r0, [r9, #0]
 428 0180 FFF7FEFF 		bl	vTaskPrioritySet
 302:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 429              		.loc 1 302 0
 430 0184 2068     		ldr	r0, [r4, #0]
 310:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );			
 431              		.loc 1 310 0
 432 0186 0221     		movs	r1, #2
 302:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 433              		.loc 1 302 0
 434 0188 5528     		cmp	r0, #85
 306:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 435              		.loc 1 306 0
 436 018a 08BF     		it	eq
 437 018c 2F60     		streq	r7, [r5, #0]
 310:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );			
 438              		.loc 1 310 0
 439 018e D9F80000 		ldr	r0, [r9, #0]
 440 0192 FFF7FEFF 		bl	vTaskPrioritySet
 273:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 441              		.loc 1 273 0
 442 0196 029A     		ldr	r2, [sp, #8]
 443 0198 531C     		adds	r3, r2, #1
 444 019a 042B     		cmp	r3, #4
 445 019c 0293     		str	r3, [sp, #8]
 446 019e D6DD     		ble	.L52
 315:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 447              		.loc 1 315 0
 448 01a0 2768     		ldr	r7, [r4, #0]
 317:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 449              		.loc 1 317 0
 450 01a2 1420     		movs	r0, #20
 315:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 451              		.loc 1 315 0
 452 01a4 552F     		cmp	r7, #85
 453 01a6 05D0     		beq	.L69
 454              	.L51:
 317:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 455              		.loc 1 317 0
 456 01a8 FFF7FEFF 		bl	vTaskDelay
 315:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 457              		.loc 1 315 0
 458 01ac 2768     		ldr	r7, [r4, #0]
 317:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 459              		.loc 1 317 0
 460 01ae 1420     		movs	r0, #20
 315:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 461              		.loc 1 315 0
 462 01b0 552F     		cmp	r7, #85
 463 01b2 F9D1     		bne	.L51
 464              	.L69:
 320:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 465              		.loc 1 320 0
 466 01b4 40F2000A 		movw	sl, #:lower16:.LANCHOR0
 319:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 467              		.loc 1 319 0
 468 01b8 FFF7FEFF 		bl	vTaskDelay
 320:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 469              		.loc 1 320 0
 470 01bc C0F2000A 		movt	sl, #:upper16:.LANCHOR0
 471 01c0 0021     		movs	r1, #0
 472 01c2 CAF80010 		str	r1, [sl, #0]
 333:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 473              		.loc 1 333 0
 474 01c6 0291     		str	r1, [sp, #8]
 337:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 475              		.loc 1 337 0
 476 01c8 0127     		movs	r7, #1
 477              	.L50:
 335:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 478              		.loc 1 335 0
 479 01ca 0022     		movs	r2, #0
 480 01cc 1346     		mov	r3, r2
 481 01ce 3068     		ldr	r0, [r6, #0]
 482 01d0 03A9     		add	r1, sp, #12
 483 01d2 FFF7FEFF 		bl	xQueueAltGenericReceive
 484 01d6 0128     		cmp	r0, #1
 333:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 485              		.loc 1 333 0
 486 01d8 0298     		ldr	r0, [sp, #8]
 337:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 487              		.loc 1 337 0
 488 01da 18BF     		it	ne
 489 01dc 2F60     		strne	r7, [r5, #0]
 333:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 490              		.loc 1 333 0
 491 01de 00F10102 		add	r2, r0, #1
 492 01e2 042A     		cmp	r2, #4
 493 01e4 0292     		str	r2, [sp, #8]
 494 01e6 F0DD     		ble	.L50
 343:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskResume( xSecondary );
 495              		.loc 1 343 0
 496 01e8 D9F80000 		ldr	r0, [r9, #0]
 497 01ec FFF7FEFF 		bl	vTaskResume
 346:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 498              		.loc 1 346 0
 499 01f0 2368     		ldr	r3, [r4, #0]
 500 01f2 552B     		cmp	r3, #85
 501 01f4 05D0     		beq	.L66
 502              	.L49:
 348:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 503              		.loc 1 348 0
 504 01f6 1420     		movs	r0, #20
 505 01f8 FFF7FEFF 		bl	vTaskDelay
 346:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 506              		.loc 1 346 0
 507 01fc 2768     		ldr	r7, [r4, #0]
 508 01fe 552F     		cmp	r7, #85
 509 0200 F9D1     		bne	.L49
 510              	.L66:
 350:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 511              		.loc 1 350 0
 512 0202 1420     		movs	r0, #20
 351:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 513              		.loc 1 351 0
 514 0204 40F2000B 		movw	fp, #:lower16:.LANCHOR0
 350:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 515              		.loc 1 350 0
 516 0208 FFF7FEFF 		bl	vTaskDelay
 351:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xRunIndicator = 0;
 517              		.loc 1 351 0
 518 020c C0F2000B 		movt	fp, #:upper16:.LANCHOR0
 519 0210 0021     		movs	r1, #0
 520 0212 CBF80010 		str	r1, [fp, #0]
 353:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 521              		.loc 1 353 0
 522 0216 0291     		str	r1, [sp, #8]
 359:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 523              		.loc 1 359 0
 524 0218 0127     		movs	r7, #1
 525              	.L48:
 357:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 526              		.loc 1 357 0
 527 021a 0022     		movs	r2, #0
 528 021c 1346     		mov	r3, r2
 529 021e 02A9     		add	r1, sp, #8
 530 0220 3068     		ldr	r0, [r6, #0]
 531 0222 FFF7FEFF 		bl	xQueueAltGenericSend
 365:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 532              		.loc 1 365 0
 533 0226 0022     		movs	r2, #0
 357:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltSendToBack( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 534              		.loc 1 357 0
 535 0228 0128     		cmp	r0, #1
 365:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 536              		.loc 1 365 0
 537 022a 1346     		mov	r3, r2
 359:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 538              		.loc 1 359 0
 539 022c 18BF     		it	ne
 540 022e 2F60     		strne	r7, [r5, #0]
 365:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 541              		.loc 1 365 0
 542 0230 03A9     		add	r1, sp, #12
 543 0232 3068     		ldr	r0, [r6, #0]
 544 0234 FFF7FEFF 		bl	xQueueAltGenericReceive
 370:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 545              		.loc 1 370 0
 546 0238 2268     		ldr	r2, [r4, #0]
 378:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 547              		.loc 1 378 0
 548 023a 0521     		movs	r1, #5
 365:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xQueueAltReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 549              		.loc 1 365 0
 550 023c 0128     		cmp	r0, #1
 367:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 551              		.loc 1 367 0
 552 023e 18BF     		it	ne
 553 0240 2F60     		strne	r7, [r5, #0]
 370:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 554              		.loc 1 370 0
 555 0242 552A     		cmp	r2, #85
 373:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 556              		.loc 1 373 0
 557 0244 08BF     		it	eq
 558 0246 2F60     		streq	r7, [r5, #0]
 378:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 559              		.loc 1 378 0
 560 0248 D9F80000 		ldr	r0, [r9, #0]
 561 024c FFF7FEFF 		bl	vTaskPrioritySet
 382:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 562              		.loc 1 382 0
 563 0250 2368     		ldr	r3, [r4, #0]
 388:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );			
 564              		.loc 1 388 0
 565 0252 0221     		movs	r1, #2
 382:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 566              		.loc 1 382 0
 567 0254 552B     		cmp	r3, #85
 386:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 				xErrorOccurred = pdTRUE;
 568              		.loc 1 386 0
 569 0256 08BF     		it	eq
 570 0258 2F60     		streq	r7, [r5, #0]
 388:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );			
 571              		.loc 1 388 0
 572 025a D9F80000 		ldr	r0, [r9, #0]
 573 025e FFF7FEFF 		bl	vTaskPrioritySet
 353:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 574              		.loc 1 353 0
 575 0262 0298     		ldr	r0, [sp, #8]
 576 0264 421C     		adds	r2, r0, #1
 577 0266 042A     		cmp	r2, #4
 578 0268 0292     		str	r2, [sp, #8]
 579 026a D6DD     		ble	.L48
 393:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 580              		.loc 1 393 0
 581 026c 2768     		ldr	r7, [r4, #0]
 395:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 582              		.loc 1 395 0
 583 026e 1420     		movs	r0, #20
 393:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 584              		.loc 1 393 0
 585 0270 552F     		cmp	r7, #85
 586 0272 05D0     		beq	.L70
 587              	.L47:
 395:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 588              		.loc 1 395 0
 589 0274 FFF7FEFF 		bl	vTaskDelay
 393:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 590              		.loc 1 393 0
 591 0278 2768     		ldr	r7, [r4, #0]
 395:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 			vTaskDelay( bktSHORT_WAIT );
 592              		.loc 1 395 0
 593 027a 1420     		movs	r0, #20
 393:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 594              		.loc 1 393 0
 595 027c 552F     		cmp	r7, #85
 596 027e F9D1     		bne	.L47
 597              	.L70:
 397:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		vTaskDelay( bktSHORT_WAIT );
 598              		.loc 1 397 0
 599 0280 FFF7FEFF 		bl	vTaskDelay
 399:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xPrimaryCycles++;
 600              		.loc 1 399 0
 601 0284 0199     		ldr	r1, [sp, #4]
 602 0286 0B68     		ldr	r3, [r1, #0]
 603 0288 581C     		adds	r0, r3, #1
 604 028a 0860     		str	r0, [r1, #0]
 400:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	}
 605              		.loc 1 400 0
 606 028c D0E6     		b	.L46
 607              		.cfi_endproc
 608              	.LFE1:
 610 028e 00BF     		.section	.text.vCreateAltBlockTimeTasks,"ax",%progbits
 611              		.align	2
 612              		.global	vCreateAltBlockTimeTasks
 613              		.thumb
 614              		.thumb_func
 616              	vCreateAltBlockTimeTasks:
 617              	.LFB0:
 105:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
 618              		.loc 1 105 0
 619              		.cfi_startproc
 620              		@ args = 0, pretend = 0, frame = 0
 621              		@ frame_needed = 0, uses_anonymous_args = 0
 622 0000 70B5     		push	{r4, r5, r6, lr}
 623              	.LCFI4:
 624              		.cfi_def_cfa_offset 16
 625              		.cfi_offset 14, -4
 626              		.cfi_offset 6, -8
 627              		.cfi_offset 5, -12
 628              		.cfi_offset 4, -16
 107:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
 629              		.loc 1 107 0
 630 0002 0421     		movs	r1, #4
 105:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
 631              		.loc 1 105 0
 632 0004 84B0     		sub	sp, sp, #16
 633              	.LCFI5:
 634              		.cfi_def_cfa_offset 32
 107:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
 635              		.loc 1 107 0
 636 0006 0022     		movs	r2, #0
 637 0008 0520     		movs	r0, #5
 638 000a FFF7FEFF 		bl	xQueueGenericCreate
 639 000e 40F20003 		movw	r3, #:lower16:.LANCHOR1
 640 0012 C0F20003 		movt	r3, #:upper16:.LANCHOR1
 119:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed portCHAR * )"FBTest1", configMINIMAL_STACK_SIZE, 
 641              		.loc 1 119 0
 642 0016 0024     		movs	r4, #0
 107:../FreeRTOS/Demo/Common/Minimal/AltBlock.c ****     xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
 643              		.loc 1 107 0
 644 0018 1860     		str	r0, [r3, #0]
 119:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed portCHAR * )"FBTest1", configMINIMAL_STACK_SIZE, 
 645              		.loc 1 119 0
 646 001a 40F20001 		movw	r1, #:lower16:.LC0
 647 001e 40F20000 		movw	r0, #:lower16:vPrimaryBlockTimeTestTask
 648 0022 7822     		movs	r2, #120
 649 0024 2346     		mov	r3, r4
 650 0026 0325     		movs	r5, #3
 651 0028 C0F20001 		movt	r1, #:upper16:.LC0
 652 002c C0F20000 		movt	r0, #:upper16:vPrimaryBlockTimeTestTask
 653 0030 0095     		str	r5, [sp, #0]
 654 0032 0194     		str	r4, [sp, #4]
 655 0034 0294     		str	r4, [sp, #8]
 656 0036 0394     		str	r4, [sp, #12]
 120:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed portCHAR * )"FBTest2", configMINIMAL_STACK_SIZE
 657              		.loc 1 120 0
 658 0038 40F20005 		movw	r5, #:lower16:.LANCHOR4
 119:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed portCHAR * )"FBTest1", configMINIMAL_STACK_SIZE, 
 659              		.loc 1 119 0
 660 003c FFF7FEFF 		bl	xTaskGenericCreate
 120:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed portCHAR * )"FBTest2", configMINIMAL_STACK_SIZE
 661              		.loc 1 120 0
 662 0040 40F20000 		movw	r0, #:lower16:vSecondaryBlockTimeTestTask
 663 0044 40F20001 		movw	r1, #:lower16:.LC1
 664 0048 C0F20005 		movt	r5, #:upper16:.LANCHOR4
 665 004c 0226     		movs	r6, #2
 666 004e C0F20001 		movt	r1, #:upper16:.LC1
 667 0052 7822     		movs	r2, #120
 668 0054 2346     		mov	r3, r4
 669 0056 C0F20000 		movt	r0, #:upper16:vSecondaryBlockTimeTestTask
 670 005a 0096     		str	r6, [sp, #0]
 671 005c 0195     		str	r5, [sp, #4]
 672 005e 0294     		str	r4, [sp, #8]
 673 0060 0394     		str	r4, [sp, #12]
 674 0062 FFF7FEFF 		bl	xTaskGenericCreate
 121:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** }
 675              		.loc 1 121 0
 676 0066 04B0     		add	sp, sp, #16
 677 0068 70BD     		pop	{r4, r5, r6, pc}
 678              		.cfi_endproc
 679              	.LFE0:
 681 006a 00BF     		.section	.text.xAreAltBlockTimeTestTasksStillRunning,"ax",%progbits
 682              		.align	2
 683              		.global	xAreAltBlockTimeTestTasksStillRunning
 684              		.thumb
 685              		.thumb_func
 687              	xAreAltBlockTimeTestTasksStillRunning:
 688              	.LFB3:
 508:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** }
 509:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** /*-----------------------------------------------------------*/
 510:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 511:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portBASE_TYPE xAreAltBlockTimeTestTasksStillRunning( void )
 512:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
 689              		.loc 1 512 0
 690              		.cfi_startproc
 691              		@ args = 0, pretend = 0, frame = 0
 692              		@ frame_needed = 0, uses_anonymous_args = 0
 693              		@ link register save eliminated.
 694              	.LVL23:
 513:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
 514:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portBASE_TYPE xReturn = pdPASS;
 515:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 516:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	/* Have both tasks performed at least one cycle since this function was
 517:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	last called? */
 518:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	if( xPrimaryCycles == xLastPrimaryCycleCount )
 519:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	{
 520:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xReturn = pdFAIL;
 521:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	}
 522:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 523:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	if( xSecondaryCycles == xLastSecondaryCycleCount )
 695              		.loc 1 523 0
 696 0000 40F20000 		movw	r0, #:lower16:.LANCHOR3
 697 0004 40F20002 		movw	r2, #:lower16:.LANCHOR7
 698 0008 C0F20000 		movt	r0, #:upper16:.LANCHOR3
 699 000c C0F20002 		movt	r2, #:upper16:.LANCHOR7
 512:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** {
 700              		.loc 1 512 0
 701 0010 70B4     		push	{r4, r5, r6}
 702              	.LCFI6:
 703              		.cfi_def_cfa_offset 12
 704              		.cfi_offset 6, -4
 705              		.cfi_offset 5, -8
 706              		.cfi_offset 4, -12
 707              		.loc 1 523 0
 708 0012 0468     		ldr	r4, [r0, #0]
 709 0014 1668     		ldr	r6, [r2, #0]
 518:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	if( xPrimaryCycles == xLastPrimaryCycleCount )
 710              		.loc 1 518 0
 711 0016 40F20001 		movw	r1, #:lower16:.LANCHOR5
 712 001a 40F20003 		movw	r3, #:lower16:.LANCHOR6
 713 001e C0F20001 		movt	r1, #:upper16:.LANCHOR5
 714 0022 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 715              		.loc 1 523 0
 716 0026 B442     		cmp	r4, r6
 518:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	if( xPrimaryCycles == xLastPrimaryCycleCount )
 717              		.loc 1 518 0
 718 0028 0D68     		ldr	r5, [r1, #0]
 719 002a 1868     		ldr	r0, [r3, #0]
 720              	.LVL24:
 721              		.loc 1 523 0
 722 002c 0FD0     		beq	.L75
 514:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** portBASE_TYPE xReturn = pdPASS;
 723              		.loc 1 514 0
 724 002e 281A     		subs	r0, r5, r0
 725 0030 18BF     		it	ne
 726 0032 0120     		movne	r0, #1
 727              	.L73:
 728              	.LVL25:
 524:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	{
 525:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xReturn = pdFAIL;
 526:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	}
 527:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 528:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	if( xErrorOccurred == pdTRUE )
 729              		.loc 1 528 0
 730 0034 40F2000C 		movw	ip, #:lower16:.LANCHOR2
 731 0038 C0F2000C 		movt	ip, #:upper16:.LANCHOR2
 732 003c DCF80010 		ldr	r1, [ip, #0]
 529:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	{
 530:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xReturn = pdFAIL;
 531:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	}
 532:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 533:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xLastSecondaryCycleCount = xSecondaryCycles;
 733              		.loc 1 533 0
 734 0040 1460     		str	r4, [r2, #0]
 534:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	xLastPrimaryCycleCount = xPrimaryCycles;
 735              		.loc 1 534 0
 736 0042 1D60     		str	r5, [r3, #0]
 535:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 
 536:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 	return xReturn;
 537:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** }
 737              		.loc 1 537 0
 738 0044 0129     		cmp	r1, #1
 739 0046 08BF     		it	eq
 740 0048 0020     		moveq	r0, #0
 741              	.LVL26:
 742 004a 70BC     		pop	{r4, r5, r6}
 743 004c 7047     		bx	lr
 744              	.LVL27:
 745              	.L75:
 525:../FreeRTOS/Demo/Common/Minimal/AltBlock.c **** 		xReturn = pdFAIL;
 746              		.loc 1 525 0
 747 004e 0020     		movs	r0, #0
 748 0050 F0E7     		b	.L73
 749              		.cfi_endproc
 750              	.LFE3:
 752 0052 00BF     		.section	.bss.xLastSecondaryCycleCount.4245,"aw",%nobits
 753              		.align	2
 754              		.set	.LANCHOR7,. + 0
 757              	xLastSecondaryCycleCount.4245:
 758 0000 00000000 		.space	4
 759              		.section	.bss.xPrimaryCycles,"aw",%nobits
 760              		.align	2
 761              		.set	.LANCHOR5,. + 0
 764              	xPrimaryCycles:
 765 0000 00000000 		.space	4
 766              		.section	.bss.xRunIndicator,"aw",%nobits
 767              		.align	2
 768              		.set	.LANCHOR0,. + 0
 771              	xRunIndicator:
 772 0000 00000000 		.space	4
 773              		.section	.bss.xSecondary,"aw",%nobits
 774              		.align	2
 775              		.set	.LANCHOR4,. + 0
 778              	xSecondary:
 779 0000 00000000 		.space	4
 780              		.section	.bss.xTestQueue,"aw",%nobits
 781              		.align	2
 782              		.set	.LANCHOR1,. + 0
 785              	xTestQueue:
 786 0000 00000000 		.space	4
 787              		.section	.bss.xErrorOccurred,"aw",%nobits
 788              		.align	2
 789              		.set	.LANCHOR2,. + 0
 792              	xErrorOccurred:
 793 0000 00000000 		.space	4
 794              		.section	.rodata.str1.4,"aMS",%progbits,1
 795              		.align	2
 796              	.LC0:
 797 0000 46425465 		.ascii	"FBTest1\000"
 797      73743100 
 798              	.LC1:
 799 0008 46425465 		.ascii	"FBTest2\000"
 799      73743200 
 800              		.section	.bss.xSecondaryCycles,"aw",%nobits
 801              		.align	2
 802              		.set	.LANCHOR3,. + 0
 805              	xSecondaryCycles:
 806 0000 00000000 		.space	4
 807              		.section	.bss.xLastPrimaryCycleCount.4244,"aw",%nobits
 808              		.align	2
 809              		.set	.LANCHOR6,. + 0
 812              	xLastPrimaryCycleCount.4244:
 813 0000 00000000 		.space	4
 814              		.text
 815              	.Letext0:
 816              		.file 2 "../FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM3/portmacro.h"
 817              		.file 3 "../FreeRTOS/Source/include/task.h"
 818              		.file 4 "../FreeRTOS/Source/include/queue.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AltBlock.c
     /tmp/ccZN7Psc.s:19     .text.vSecondaryBlockTimeTestTask:00000000 $t
     /tmp/ccZN7Psc.s:23     .text.vSecondaryBlockTimeTestTask:00000000 vSecondaryBlockTimeTestTask
     /tmp/ccZN7Psc.s:768    .bss.xRunIndicator:00000000 .LANCHOR0
     /tmp/ccZN7Psc.s:782    .bss.xTestQueue:00000000 .LANCHOR1
     /tmp/ccZN7Psc.s:789    .bss.xErrorOccurred:00000000 .LANCHOR2
     /tmp/ccZN7Psc.s:802    .bss.xSecondaryCycles:00000000 .LANCHOR3
     /tmp/ccZN7Psc.s:162    .text.vPrimaryBlockTimeTestTask:00000000 $t
     /tmp/ccZN7Psc.s:166    .text.vPrimaryBlockTimeTestTask:00000000 vPrimaryBlockTimeTestTask
     /tmp/ccZN7Psc.s:761    .bss.xPrimaryCycles:00000000 .LANCHOR5
     /tmp/ccZN7Psc.s:775    .bss.xSecondary:00000000 .LANCHOR4
     /tmp/ccZN7Psc.s:611    .text.vCreateAltBlockTimeTasks:00000000 $t
     /tmp/ccZN7Psc.s:616    .text.vCreateAltBlockTimeTasks:00000000 vCreateAltBlockTimeTasks
     /tmp/ccZN7Psc.s:796    .rodata.str1.4:00000000 .LC0
     /tmp/ccZN7Psc.s:798    .rodata.str1.4:00000008 .LC1
     /tmp/ccZN7Psc.s:682    .text.xAreAltBlockTimeTestTasksStillRunning:00000000 $t
     /tmp/ccZN7Psc.s:687    .text.xAreAltBlockTimeTestTasksStillRunning:00000000 xAreAltBlockTimeTestTasksStillRunning
     /tmp/ccZN7Psc.s:754    .bss.xLastSecondaryCycleCount.4245:00000000 .LANCHOR7
     /tmp/ccZN7Psc.s:809    .bss.xLastPrimaryCycleCount.4244:00000000 .LANCHOR6
     /tmp/ccZN7Psc.s:753    .bss.xLastSecondaryCycleCount.4245:00000000 $d
     /tmp/ccZN7Psc.s:757    .bss.xLastSecondaryCycleCount.4245:00000000 xLastSecondaryCycleCount.4245
     /tmp/ccZN7Psc.s:760    .bss.xPrimaryCycles:00000000 $d
     /tmp/ccZN7Psc.s:764    .bss.xPrimaryCycles:00000000 xPrimaryCycles
     /tmp/ccZN7Psc.s:767    .bss.xRunIndicator:00000000 $d
     /tmp/ccZN7Psc.s:771    .bss.xRunIndicator:00000000 xRunIndicator
     /tmp/ccZN7Psc.s:774    .bss.xSecondary:00000000 $d
     /tmp/ccZN7Psc.s:778    .bss.xSecondary:00000000 xSecondary
     /tmp/ccZN7Psc.s:781    .bss.xTestQueue:00000000 $d
     /tmp/ccZN7Psc.s:785    .bss.xTestQueue:00000000 xTestQueue
     /tmp/ccZN7Psc.s:788    .bss.xErrorOccurred:00000000 $d
     /tmp/ccZN7Psc.s:792    .bss.xErrorOccurred:00000000 xErrorOccurred
     /tmp/ccZN7Psc.s:795    .rodata.str1.4:00000000 $d
     /tmp/ccZN7Psc.s:801    .bss.xSecondaryCycles:00000000 $d
     /tmp/ccZN7Psc.s:805    .bss.xSecondaryCycles:00000000 xSecondaryCycles
     /tmp/ccZN7Psc.s:808    .bss.xLastPrimaryCycleCount.4244:00000000 $d
     /tmp/ccZN7Psc.s:812    .bss.xLastPrimaryCycleCount.4244:00000000 xLastPrimaryCycleCount.4244
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vTaskSuspend
vPortEnterCritical
xTaskGetTickCount
xQueueAltGenericSend
vPortExitCritical
xQueueAltGenericReceive
vTaskResume
vTaskDelay
vTaskPrioritySet
xQueueGenericCreate
xTaskGenericCreate
